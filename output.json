{
  "./requirements.txt": "numpy==2.1.1\npygame==2.6.0\n",
  "./Notes.md": "# To do\n * s'assurer que tous les spells renvoient un array de targets\n * S'assurer que les effects ne s'appliquent qu'à 1 target\n    \n### refactorisation de la classe effects\n\nl'effet apply to all est mavais pour la mémoire, \nloop sur les target à chaque effet\non cast\n   * apply to all\n       * loop on effects array\n\n",
  "./main.py": "import pygame\nfrom scenes.scene_manager import SceneManager\nfrom state.grid_state import State\n\npygame.init()\n\nSceneManager(State()).run()\n\npygame.quit()\n",
  "./agregate.py": "import os\nimport json\n\ndef read_files_in_folder(folder_path):\n    file_data = {}\n    valid_extensions = {\".py\", \".txt\", \".md\"}  # add more as needed\n    \n    for root, _, files in os.walk(folder_path):\n        # Skip unwanted directories\n        if \"env\" in root.split(os.sep) or \".git\" in root.split(os.sep):\n            continue\n        \n        for file in files:\n            # Skip .git* files\n            if file.startswith(\".git\"):\n                continue\n            \n            file_path = os.path.join(root, file)\n            _, ext = os.path.splitext(file_path)\n            \n            # Skip files that don't match our valid extensions\n            if ext.lower() not in valid_extensions:\n                continue\n            \n            try:\n                with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                    file_data[file_path] = f.read()\n            except UnicodeDecodeError:\n                print(f\"Skipping file (not valid UTF-8): {file_path}\")\n    \n    return file_data\n\nif __name__ == \"__main__\":\n    folder_path = \"./\"\n    output_file = \"output.json\"\n    \n    # Remove output.json if it exists\n    if os.path.exists(output_file):\n        os.remove(output_file)\n    \n    files_content = read_files_in_folder(folder_path)\n    \n    with open(output_file, \"w\", encoding=\"utf-8\") as out:\n        json.dump(files_content, out, ensure_ascii=False, indent=2)\n    \n    print(f\"File contents have been written to {output_file}\")\n",
  "./patterns/observer.py": "class Observable:\n    def __init__(self):\n        self._observers = []\n\n    def add_observer(self, observer):\n        self._observers.append(observer)\n\n    def remove_observer(self, observer):\n        self._observers.remove(observer)\n\n    def notify_observers(self, event, *args):\n        for observer in self._observers:\n            observer.update(event, *args)\n\nclass Observer:\n    def update(self, event, *args):\n        \"\"\"Observers must implement this method to react to state changes.\"\"\"\n        print(self)\n        raise NotImplementedError(\"Observer subclasses  must implement 'update()'\")\n",
  "./state/grid_state.py": "import pygame\nfrom data.spells import Spells\nfrom data.effects import Status\n\nfrom utils.colors import colors\nfrom utils.constants import SCREEN\nfrom utils.functions import fade_out_surface\n\nfrom classes.grid import Pion\nfrom classes.character import Character\n\nfrom patterns.observer import Observable\n\npygame.font.init()\n\nclass GameStates:\n  IDLE = \"IDLE\"\n  MOVING = \"MOVING\"\n  ATTACKING = \"ATTACKING\"\n  TURN_CHANGED = \"TURN_CHANGE\"\n  TURN_CHANGING = \"TURN_CHANGING\"\n  TARGET_SELECTION = \"TARGET_SELECTION\"\n\nclass State(Observable):\n  def __init__(self):\n    super().__init__()\n    self.turn = 'Team 1'\n    self.turn_number = 1\n    self.LIST_PIONS = []\n    self.TEAMS = {\n      \"Team 1\": {\"color\": colors.PURPLE, \"pions\": []},\n      \"Team 2\": {\"color\": colors.CARMIN, \"pions\": []},\n    }\n    self.active_team = self.TEAMS[self.turn]\n    self.moving = False\n    self.attacking = False\n    self.active_spell = False\n    self.change_turn = False\n    self.current_state = GameStates.IDLE\n    self.fade_turn_pannel = fade_out_surface(SCREEN, 'Team 1', self.TEAMS[self.turn][\"color\"])\n\n  def kill_the_dead(self, grid):\n    for pion in self.LIST_PIONS[:]:  # Iterate over a copy of the list\n      if pion.character.hp <= 0:\n        grid.remove_pion(pion)\n\n  def set_state(self, new_state):\n    \"\"\"Updates the game state and notifies UI observers\"\"\"\n    if self.current_state != new_state:\n      self.current_state = new_state\n      for observer in self._observers:\n        print(observer)\n      self.notify_observers(\"STATE_CHANGED\", new_state)\n\n\n  def next_turn(self):\n    \"\"\"Handles turn change logic\"\"\"\n    self.set_state(GameStates.TURN_CHANGING)\n\n    self.turn = \"Team 2\" if self.turn == \"Team 1\" else \"Team 1\"\n    if self.turn == \"Team 1\": self.turn_number += 1\n\n    self.notify_observers(\"TURN_CHANGED\", self.turn, self.turn_number)\n    \n    self.fade_turn_pannel = fade_out_surface(SCREEN, self.turn, self.TEAMS[self.turn][\"color\"])\n    \n    for pion in self.TEAMS[self.turn][ \"pions\" ]:\n      if pion.character:\n        character = pion.character\n        if character.hp > 0:\n          character.mp = character.max_mp\n          character.turn_reset(self.turn_number)\n        for status in character.status:\n          Status[status['name']].life_cycle(character)\n\n    self.change_turn = True\n    self.active_team = self.TEAMS[self.turn]\n\n    self.set_state(GameStates.IDLE)\n\n  def setup(self, team, team2):\n    for i, member in enumerate(team):\n      match i:\n        case 0: coord = (2, 2)\n        case 1: coord = (2, 4)\n        case 2: coord = (2, 6)\n      pion = Pion(\"Team 1\", coord, member)\n      self.LIST_PIONS.append(pion)\n      self.TEAMS[\"Team 1\"][\"pions\"].append(pion)\n    \n    for i, char in enumerate(team2):\n      match i:\n        case 0: coord = (10, 2)\n        case 1: coord = (10, 4)\n        case 2: coord = (10, 6)\n      pion = Pion(\"Team 2\", coord, char)\n      self.LIST_PIONS.append(pion)\n      self.TEAMS['Team 2'][\"pions\"].append(pion) \n",
  "./scenes/__init__.py": "",
  "./scenes/menu.py": "import pygame\nfrom classes.scene import Scene\n\nclass MenuScene(Scene):\n  def __init__(self):\n      super().__init__()\n      self.font = pygame.font.Font(None, 50)\n      self.bigfont = pygame.font.Font(None, 200)\n      self.smallfont = pygame.font.Font(None, 30)\n\n  def handle_events(self, events):\n      for event in events:\n          if event.type == pygame.KEYDOWN:\n              if event.key == pygame.K_RETURN:  # Press Enter to start game\n                  return 'game'  # Return the name of the next scene\n\n  def render(self, screen):\n      screen.fill((30, 30, 30))  # Dark background\n      name = self.smallfont.render('Beyond the Veil', True, (255, 255, 255))\n      name_rect = name.get_rect(center=(screen.get_width() // 2, screen.get_height() // 3))\n    \n      title = self.bigfont.render('BATTLER', True, (255, 255, 255))\n      title_rect = title.get_rect(center=(screen.get_width() // 2, screen.get_height() // 2))\n    \n      text = self.font.render('Press Enter to Start', True, (255, 255, 255))\n      text_rect = text.get_rect(center=(screen.get_width() // 2, (screen.get_height() // 3 )*2))\n    \n      screen.blit(text, text_rect)\n      screen.blit(title, title_rect)\n      screen.blit(name, name_rect)\n",
  "./scenes/scene_build_team.py": "import pygame\nfrom classes.scene import Scene\nfrom classes.ui import Button\nfrom data.spells import Spells\nfrom classes.character import Character\nfrom utils.colors import colors\nfrom utils.constants import WIDTH, HEIGHT\n\nspells = [Spells[\"Fireball\"], Spells['Stream']]\nspells2 = [Spells[\"Splash\"], Spells['Spark']]\ncharacters = []\nteam = []\nbuttons = []\nspots = []\n\nTouko = Character('Touko',  2, 4, 4, './sprite_sheet/past.png'  , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60)\nGirl  = Character('Girl' ,  2, 4, 3, './sprite_sheet/girl.png'  , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -3)\nScott = Character('Scott', 12, 4, 5, './sprite_sheet/Scott.png' , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nGreen = Character('Green', 12, 4, 5, './sprite_sheet/green.png' , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nAzure = Character('Azure', 12, 4, 3, './sprite_sheet/azure.png' , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nLance = Character('Lance', 12, 4, 5, './sprite_sheet/silver.png', spells2, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nDemo  = Character('Demo' , 12, 4, 3, './sprite_sheet/Demo_sprite2.png', spells, [\"bottom\", \"left\", \"right\", \"top\"], 34, 40, 5)\nProfessor = Character('Professor', 12, 4, 5, './sprite_sheet/professor.png', spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60)\n\ncharacters = [Lance,  Azure, Girl, Demo,  Green,  Scott]\n\nclass TeamSelect(Scene):\n  def __init__(self, state):\n    super().__init__()\n    self.font = pygame.font.Font(None, 40)\n    self.next = False\n    self.btn_next = Button(\n      WIDTH - 150, HEIGHT - 150, 130, 50, \"Battle !!!\", colors.BLUE, colors.DARK_BLUE, colors.BLACK, 36,\n      action=self.battle\n    )\n    self.state = state\n\n    for i, character in enumerate(characters):\n      x = (i+1) * 100\n      btn = Button(\n        x, 100, 50, 50, \"\", colors.BLUE, colors.DARK_BLUE, colors.BLACK, 36,\n        action=lambda ch=character: self.add_to_team(ch)\n      )\n      buttons.append(btn)\n\n  def handle_events(self, events):\n    if self.next:\n      return 'battle'\n    for event in events:\n      if event.type == pygame.KEYDOWN:\n        if event.key == pygame.K_ESCAPE:\n          return 'menu'\n\n      for button in buttons:\n        button.handle_event(event)\n\n      for button in spots:\n        button.handle_event(event)\n\n      self.btn_next.handle_event(event)\n        \n  def update(self):\n    pass\n    \n  def render(self, screen):\n    \n    screen.fill((30, 30, 30))  # Dark background\n    title = self.font.render('Chose three members for your team', True, (255, 255, 255))\n    title_rect = title.get_rect(center=(screen.get_width() // 2, 50))\n    screen.blit(title, title_rect)\n\n\n    for i, (character, button) in enumerate(zip(team, spots)):\n      button.draw(screen)\n    \n      sprite = character.sprite[\"bottom\"][0]\n      sprite_rect = sprite.get_rect()\n      sprite_center_x = button.rect.x + (button.rect.width - sprite_rect.width) // 2\n      sprite_center_y = button.rect.y + (button.rect.height - sprite_rect.height) // 2 + character.offsetx\n\n      screen.blit(sprite, (sprite_center_x, sprite_center_y))\n      \n    for i, (character, button) in enumerate(zip(characters, buttons)):\n      button.draw(screen)\n\n      sprite = character.sprite[\"bottom\"][0]\n      sprite_rect = sprite.get_rect()\n      sprite_center_x = button.rect.x + (button.rect.width - sprite_rect.width) // 2\n      sprite_center_y = button.rect.y + (button.rect.height - sprite_rect.height) // 2 + character.offsetx\n\n      screen.blit(sprite, (sprite_center_x, sprite_center_y))\n\n    if len(team) == 3:\n      self.btn_next.draw(screen)\n      \n  def add_to_team(self, character):\n    global spots\n    if len(team) < 3 and character not in team:\n      team.append(character)\n    self.set_spots()\n      \n\n  def set_spots(self,):\n    global spots\n    spots = []\n    for i, member in enumerate(team):\n      x = 250 + (i*100)\n      btn = Button(\n        x, 300, 50, 50, \"\", colors.BLUE, colors.DARK_BLUE, colors.BLACK, 36,\n        action=lambda ch=member: self.rem_from_team(ch)\n      )\n      spots.append(btn)\n\n  def rem_from_team(self, character):\n    if character in team:\n      team.remove(character)\n    self.set_spots()\n      \n  def battle(self):\n    self.next = True\n    self.state.setup(team)\n    \n",
  "./scenes/scene_battle.py": "import pygame\nfrom classes.scene import Scene\nfrom classes.ui import Ui\nfrom data.spells import Spells\nfrom utils.colors import colors\nfrom utils.constants import HEIGHT, WIDTH, GUTTER, ROWS, COLLS, CELL_SIZE, MARGIN, SCREEN\n\nfrom classes.grid import Grid\nfrom data.spells import Spells\nfrom classes.character import Character\nspells = [Spells[\"Fireball\"], Spells['Stream']]\nspells2 = [Spells[\"Splash\"], Spells['Spark']]\n\nGirl  = Character('Girl' ,  2, 4, 3, './sprite_sheet/girl.png'  , spells,  [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -3)\nTouko = Character('Touko',  2, 4, 4, './sprite_sheet/past.png'  , spells,  [\"bottom\", \"left\", \"right\", \"top\"], 60, 60)\nAzure = Character('Azure', 12, 4, 3, './sprite_sheet/azure.png' , spells,  [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nLance = Character('Lance', 12, 4, 5, './sprite_sheet/silver.png', spells2, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nScott = Character('Scott', 12, 4, 5, './sprite_sheet/Scott.png' , spells,  [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nGreen = Character('Green', 12, 4, 5, './sprite_sheet/green.png' , spells,  [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\n\nclass BattleScene(Scene):\n  def __init__(self, state):\n    super().__init__()\n    self.grid = None\n    self.battle = state\n    self.clicking = False\n    self.actor = False\n    self.battle.setup([Lance, Touko, Girl], [Scott, Green, Azure])\n    self.grid = Grid(COLLS, ROWS, MARGIN, GUTTER, CELL_SIZE, self.battle)\n    self.ui = Ui(WIDTH, HEIGHT, self.battle)\n\n  # Handles player input and updates game state based on events.\n\n  # Mouse Handling:\n  # * Hover Mechanics:\n      # When the mouse hovers over the grid, detects the hovered cell and pion\n      # If hovering over an \"attack\" area, calculates and displays AoE using the spell's configuration.\n  # * Click Handling:\n      # Executes attacks if in an \"attack\" area, applying spell effects and damage.\n      # Handles movement logic when clicking on a \"move\" area.\n      # Clears AoE indicators and active cells when clicking elsewhere.\n\n  # Dead characters are removed from the grid.\n\n  def handle_events(self, events):\n    attack_in_progress = self.battle.attacking\n\n    # handle ui buttons\n    for event in events:\n      if attack_in_progress:\n        for button in self.ui.attack_buttons:\n          button.handle_event(event)\n      elif self.battle.moving:\n        self.ui.cancel_btn.handle_event(event)\n      else:\n        for button in self.ui.character_buttons:\n          button.handle_event(event)\n      self.ui.turn_button.handle_event(event)\n\n    self.battle.kill_the_dead(self.grid)\n\n    if self.grid.active and self.grid.active.pion not in self.battle.LIST_PIONS:\n      self.grid.deactivate(self.ui)\n      self.battle.attacking = False\n      self.ui.character = False\n      \n    # handle the mouse clic\n    mouse_x, mouse_y = mouse_pos = pygame.mouse.get_pos()\n    clic, _, _ = pygame.mouse.get_pressed(num_buttons=3)\n    if not clic:\n      self.clicking = False\n\n    # if the mouse hovers the grid\n    if self.grid.board.collidepoint(mouse_pos):\n      self.grid.hover = self.grid.get_hovered_cell(mouse_x, mouse_y)\n      x, y = self.grid.hover\n      hover_cell = self.grid.cells[x][y]\n      hover_pion = hover_cell.pion if hover_cell.pion != None else None\n\n      # draw the spell aoe if the mouse hovers the spell range\n      if hover_cell.area == 'attack':\n        active_spell = Spells[self.battle.active_spell]\n        if active_spell.prevision_aoe:\n          self.grid.draw_aoe(hover_cell, \"prev\", active_spell.prevision_aoe, active_spell.prevision_type)\n      else:\n        self.grid.clean_prev()\n\n      # handle clic events on the grid\n      if clic and not self.clicking:\n        self.clicking = True\n\n        # attack\n        if hover_cell.area == \"attack\":\n          if active_spell:\n            active_spell.cast( self.grid.active.pion.character, self.grid.set_targets((x,y)), self.grid)\n            self.ui.clear_aoe = True\n\n            # visually show damages\n            # for cell in targets:\n            #   if cell.pion:\n                # self.ui.character_info(cell.y, cell.y, colors.RED, \"-\"+str(active_spell.damage))\n                \n        # select grid active pion\n        # checked after attack so it is possible to cast spells on allies\n        elif hover_pion is not None and hover_pion.team == self.battle.turn:\n          self.grid.activate(x, y, self.ui)\n        \n        elif hover_pion is None:\n        # move\n          if hover_cell.area == \"move\":\n            self.grid.active.pion.move(self.grid.get_cell(x,y), self.grid)\n          else : \n            self.grid.deactivate(self.ui)\n    else:\n      self.grid.hover = (None, None)\n      if clic and not self.clicking:\n        self.clicking = True\n\n  def update(self):\n    # change turn\n    if self.battle.change_turn == True:\n      self.next_turn()\n    # clean aoe \n    if self.ui.clear_aoe:\n      self.grid.clean_aoe()\n      self.ui.clear_aoe = False\n    # set/clean ui\n    if self.grid.active :\n      if self.grid.active.pion:\n        self.ui.set_character( self.grid.active.pion.character, self.battle, self.grid)\n      else:\n        self.grid.deactivate(self.ui)\n\n  def render(self, screen):\n    screen.fill(colors.WHITE)\n    self.grid.paint(screen)\n    self.ui.draw(screen)\n    self.ui.draw_buttons(screen)\n    # self.battle.fade_turn_pannel()\n\n  def next_turn(self):\n    self.ui.character = False\n    self.grid.deactivate(self.ui)\n    self.grid.clean_aoe()\n    self.battle.attacking = False\n    self.battle.change_turn = False\n\n",
  "./scenes/scene_manager.py": "import pygame\n\nfrom scenes.menu import MenuScene\nfrom scenes.scene_battle import BattleScene\nfrom scenes.scene_build_team import TeamSelect\n\nfrom classes.ui import Ui\nfrom classes.grid import Grid\n\nfrom utils.functions import fade_to_black\nfrom utils.constants import HEIGHT, WIDTH, GUTTER, ROWS, COLLS, CELL_SIZE, MARGIN, SCREEN\n\nclass SceneManager:\n  def __init__(self, battle_state):\n    self.battle_state = battle_state\n    self.scenes = {\n        'menu': MenuScene(),\n        'game': TeamSelect(self.battle_state),\n        'battle': BattleScene(self.battle_state),\n    }\n    self.current_scene = self.scenes['battle']\n\n  def switch_scene(self, new_scene_name):\n    fade_to_black(SCREEN)\n    self.current_scene = self.scenes[new_scene_name]\n\n    if new_scene_name == 'battle':\n      self.scenes[\"battle\"].grid = Grid(COLLS, ROWS, MARGIN, GUTTER, CELL_SIZE, self.battle_state)\n      self.scenes['battle'].ui = Ui(WIDTH, HEIGHT, self.battle_state)\n\n  def run(self):\n    clock = pygame.time.Clock()\n    running = True\n    while running:\n      events = pygame.event.get()\n      for event in events:\n        if event.type == pygame.QUIT:\n          running = False\n      \n      next_scene = self.current_scene.handle_events(events)\n      if next_scene:\n        self.switch_scene(next_scene)\n\n      self.current_scene.update()\n      self.current_scene.render(SCREEN)\n  \n      pygame.display.flip()\n      clock.tick(60)\n",
  "./classes/scene.py": "class Scene:\n  def __init__(self):\n    pass\n\n  def handle_events(self, event):\n    pass\n\n  def update(self):\n    pass\n\n  def render(self):\n    pass\n",
  "./classes/ui_components.py": "import pygame\nfrom utils.colors import colors\nfrom utils.constants import HEIGHT, WIDTH, SCREEN, MARGIN\nfrom patterns.observer import Observer\n\nclass Fade:\n  def __init__(self, x, y, color, info):\n    self.x = x\n    self.y = y\n    self.font = pygame.font.Font(None, 30)\n    self.popup = self.font.render(info, True, color )\n    self.alpha = 255\n    self.fade_speed = 2\n\n  def update(self):\n    self.popup.set_alpha(self.alpha)\n    if self.alpha > 0:\n      self.alpha -= self.fade_speed\n      self.x -= 5\n      if self.alpha < 0:\n        self.alpha = 0\n    SCREEN.blit(self.popup, (self.x, self.y))\n    pygame.display.flip()\n    \nclass Button:\n  def __init__(self, x, y, width, height, text, color, hover_color, text_color, font_size, action=None):\n    self.rect = pygame.Rect(x, y, width, height)\n    self.color = color\n    self.hover_color = hover_color\n    self.text_color = text_color\n    # self.font = pygame.font.Font(None, font_size)\n    self.font = pygame.font.Font(\"./assets/rounded.ttf\", font_size)\n    self.message = text\n    self.text = self.font.render(text, True, self.text_color)\n    self.text_rect = self.text.get_rect(center=self.rect.center)\n    self.action = action\n    self.is_hovered = False\n\n  def draw(self, SCREEN):\n    if self.is_hovered:\n      pygame.draw.rect(SCREEN, self.hover_color, self.rect)\n    else:\n      pygame.draw.rect(SCREEN, self.color, self.rect)\n\n    SCREEN.blit(self.text, self.text_rect)\n\n  def handle_event(self, event):\n    mouse_pos = pygame.mouse.get_pos()\n\n    self.is_hovered = self.rect.collidepoint(mouse_pos)\n\n    if self.is_hovered and event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:\n      if self.action:\n        self.action()\n\nclass ActionButton(Button):\n  def __init__(self, x, y, text, action):\n    super().__init__(x, y, 100, 35, text, colors.BLUE, colors.DARK_BLUE, colors.BLACK, 25, action)\n\n        \nclass Banner:\n  def __init__(self, x, color):\n    self.x = x\n    self.color = color\n    self.font = pygame.font.Font(None, 30)  # Font size 30\n    self.message = ''  # Placeholder for the message\n  \n  def set_text(self, text): \n    self.message = text\n\n  def set_color(self, color): \n    self.color = color\n\n  def draw(self, SCREEN):\n    text_surface = self.font.render(self.message, True, self.color)\n    \n    rect = text_surface.get_rect()\n    rect.centerx = SCREEN.get_rect().centerx \n    rect.top = self.x  \n\n    SCREEN.blit(text_surface, rect)\n\nclass TurnBanner(Observer):\n  def __init__(self, game_state):\n    \"\"\"Initialize TurnBanner as an observer of game_state\"\"\"\n    self.game_state = game_state\n    self.game_state.add_observer(self)  # Register as an observer\n    \n    self.font = pygame.font.Font(None, 80)\n    self.banner_surface = None\n    self.text_surface = None\n    self.visible = False  # Is the banner currently active?\n    self.timer = 60  # Time to stay visible (1 second at 60 FPS)\n    self.speed = 15  # Speed of sliding effect\n\n    # Banner position (starts off-screen)\n    self.start_y = -100  # Above the screen\n    self.target_y = SCREEN.get_height() // 4  # Final position when sliding in\n    self.current_y = self.start_y  # Current Y position\n    self.direction = 'down'\n\n    self.update_surface()  # Pre-generate surfaces\n\n  def update(self, event, *args):\n    \"\"\"Triggered when the turn changes.\"\"\"\n    if event == \"TURN_CHANGED\":\n      self.current_y = self.start_y  # Reset to off-screen position\n      self.timer = 60  # Stay visible for 1 second (60 frames at 60 FPS)\n      self.visible = True  # Activate the banner\n      self.update_surface()  # Refresh text and color\n\n  def update_surface(self):\n      \"\"\"Creates the banner's surfaces only when needed.\"\"\"\n      color = self.game_state.TEAMS[self.game_state.turn][\"color\"]\n      self.banner_surface = pygame.Surface((500, 100), pygame.SRCALPHA)\n      self.banner_surface.fill(color)\n\n      message = f\"Turn: {self.game_state.turn}\"\n      self.text_surface = self.font.render(message, True, colors.BLACK)\n\n  def draw(self, screen):\n      \"\"\"Handles slide in, wait, and slide out animation.\"\"\"\n      if not self.visible:\n          return  # Skip drawing if not active\n\n      # Slide in\n      if self.current_y < self.target_y and self.direction == 'down':\n          self.current_y += self.speed\n          if self.current_y > self.target_y:  # Prevent overshooting\n              self.current_y = self.target_y\n\n      # Countdown for staying visible\n      elif self.timer > 0:\n        self.direction = \"up\"\n        self.timer -= 1  # Countdown in frames (1 second at 60 FPS)\n\n      # Slide out\n      else:\n          self.current_y -= self.speed\n          if self.current_y <= self.start_y:  # Fully off-screen\n              self.visible = False  # Hide banner\n\n      # Center the banner horizontally\n      banner_rect = self.banner_surface.get_rect(center=(SCREEN.get_width() // 2, self.current_y))\n      text_rect = self.text_surface.get_rect(center=banner_rect.center)\n\n      # Draw banner and text\n      screen.blit(self.banner_surface, banner_rect)\n      screen.blit(self.text_surface, text_rect)\n",
  "./classes/ui.py": "import pygame\npygame.font.init()\nfrom utils.colors import colors\nfrom utils.constants import HEIGHT, WIDTH, SCREEN, MARGIN\nfrom classes.ui_components import ActionButton, Button, Banner, Fade, TurnBanner\nfrom patterns.observer import Observer\nfrom state.grid_state import GameStates \n\nclass UiManager(Observer):\n    def __init__(self, game_state):\n      self.game_state = game_state\n      self.game_state.add_observer(self)\n      self.current_ui_elements = []\n\n    def update(self, event, *args):\n      \"\"\"React to state changes.\"\"\"\n      if event == \"STATE_CHANGED\":\n        new_state = args[0]\n        print(f\"UI Manager: Reacting to state -> {new_state}\")\n        self.handle_state_change(new_state)\n      elif event == \"TURN_CHANGED\":\n        self.display_turn_banner(args[0], args[1])\n\n    def handle_state_change(self, new_state):\n      \"\"\"Show or hide UI elements based on the game state.\"\"\"\n      self.current_ui_elements.clear()\n\n      if new_state == GameStates.ATTACKING:\n        self.current_ui_elements.append(AttackUI())\n      elif new_state == GameStates.MOVING:\n        self.current_ui_elements.append(MovementUI())\n      elif new_state == GameStates.TURN_CHANGING:\n        self.display_turn_banner()\n\n    def display_turn_banner(self, team, turn_number):\n      print(f\"Turn {turn_number}: {team}'s Turn!\")\n\nclass Ui(Observer):\n  def __init__(self, WIDTH, HEIGHT, game_state):\n    self.game_state = game_state\n    self.game_state.add_observer(self)\n    self.turn_display = Banner(15, colors.BLACK)\n\n    self.font  = pygame.font.Font(\"./assets/regular.ttf\", 15)\n    self.Hfont = pygame.font.Font(\"./assets/rounded.ttf\", 17)\n    self.Bfont = pygame.font.Font(\"./assets/regular.ttf\", 15)\n    self.set_turn()\n\n    self.turn_banner = TurnBanner(self.game_state)\n\n    self.clear_aoe = False\n    self.character = False\n    self.turn_button = ActionButton(WIDTH-115, 15, \"Turn\", action=self.game_state.next_turn)\n    self.character_buttons = []\n    self.attack_buttons = []\n\n    self.infos = []\n\n    self.char_anchor = {\n      \"y\" : HEIGHT - MARGIN[\"bottom\"] -18,\n      \"x\" : 10\n    }\n    self.anchor = pygame.Rect(self.char_anchor[\"x\"], self.char_anchor['y'], 400, MARGIN['bottom'])\n    self.cancel_btn = Button(230, self.char_anchor['y'] + 15, 100, 35, \"Cancel\", colors.BLUE, colors.DARK_BLUE, colors.BLACK, 25, action=lambda: self.cancel_menu(game_state))\n\n  def handle_state_change(self, new_state, args):\n    if new_state == GameStates.ATTACKING:\n      self.show_attack_ui()\n    elif new_state == GameStates.MOVING:\n      self.show_movement_ui()\n    elif new_state == GameStates.TURN_CHANGING:\n      self.turn_banner.direction = \"down\"\n      # self.show_turn_banner()\n      # new_turn, turn_number = args\n      # self.turn_display.set_text(f\"Turn: {new_turn} ({turn_number})\")\n      # self.turn_display.set_color(self.game_state.TEAMS[new_turn][\"color\"])\n      pass\n    else:\n      # self.hide_all_ui()\n      pass\n\n  def update(self, event, *args):\n    \"\"\"React to state changes.\"\"\"\n    if event == \"STATE_CHANGED\":\n      new_state = args[0]\n      print(f\"UI: Reacting to new state -> {new_state}\")\n      self.handle_state_change(new_state, args)\n      \n  def character_info(self, x, y, color, info):\n    fade = Fade(x, y, color, info)\n    self.infos.append(fade)\n    \n  def set_turn(self):\n    self.current_turn = Banner(15, colors.BLACK) \n    self.current_turn.set_text(self.game_state.turn)\n    self.current_turn.set_color(self.game_state.active_team[\"color\"])\n\n  def cancel_menu(self, game_state):\n    self.clear_aoe = True\n    game_state.moving = False\n    game_state.attacking = False\n\n  def set_character(self, character, game_state, grid, ):\n    self.character_buttons.clear()\n    self.attack_buttons.clear()\n    # elements = []\n    elements = {}\n\n    height = grid.spanY + 105\n    margin = grid.margin['left']\n    \n    self.add_character_info(elements, character, margin, height, )\n    self.create_character_buttons(game_state, grid)\n    self.create_spell_buttons(character, game_state, grid)\n    self.attack_buttons.append(self.cancel_btn)\n    # self.character = elements\n    self.character = character\n\n  def add_character_info(self, elements, character, margin, height, ):\n    name = self.Hfont.render(character.name, True, colors.BLACK)\n    hp = self.font.render(f\"{character.hp}/{character.max_hp}\", True, colors.BLACK)\n    move_info = self.font.render(f\"Mp: {character.mp}/{character.max_mp}\", True, colors.BLACK)\n  \n  def create_character_buttons(self, game_state, grid):\n    pos_y = self.char_anchor['y'] + 15\n    bas_x = 230\n \n    width= 100\n    height= 35\n \n    move    = Button(bas_x, pos_y, width, height, \"Move\", colors.BLUE, colors.DARK_BLUE, colors.BLACK, 25, action=grid.aoe_move)\n    attack  = Button(bas_x + width +10, pos_y, width, height, \"Attack\", colors.BLUE, colors.DARK_BLUE, colors.BLACK, 25, action=grid.aoe_attack)\n  \n    self.character_buttons.append(move)\n    self.character_buttons.append(attack)\n\n  def create_spell_buttons(self, character, game_state, grid):\n    pos_y = self.char_anchor['y'] + 15\n    bas_x = 230\n    \n    for i, spell in enumerate(character.spells):\n      x = bas_x + (i + 1) * (100 + 15) \n      y = pos_y\n      width, height = (100, 35)\n      btn = Button(\n        x, y, \n        width, height,\n        spell.name, \n        colors.BLUE, \n        colors.DARK_BLUE, \n        colors.BLACK, 25,\n        action=lambda spell=spell: grid.draw_aoe_from_caster(spell)\n      )\n      self.attack_buttons.append(btn)\n\n  def create_token_ui(self, character, x, y):\n    true_character = False\n    for pion in self.game_state.LIST_PIONS:\n      if pion.character.name == character.name:\n        true_character = pion.character\n        break\n\n    if not true_character:\n      self.character = False\n      print(\"ERROR => character not found\")\n      return\n    \n    pygame.draw.rect(SCREEN, colors.BLACK, self.anchor , 1)\n    \n    # draw portrait\n    portrait_rayon = (MARGIN['bottom'] )/2\n    portrait_x = x + 20 + portrait_rayon\n    portrait_y = y + portrait_rayon\n    portrait = pygame.draw.circle(SCREEN,colors.BLACK, (portrait_x , portrait_y) , portrait_rayon ,1)\n\n    move_info = self.font.render(f\"Mp: {character.mp}/{character.max_mp}\", True, colors.BLACK)\n    \n    # draw name\n    name_w = (portrait_rayon * 2) - 8\n    name_h = 20\n    name_x = portrait.center[0] - portrait_rayon + 4\n    name_y = portrait.center[1] + portrait_rayon - name_h/2\n    name_detail = ((name_x, name_y),(name_w, 20))\n    pygame.draw.rect(SCREEN, colors.WHITE, name_detail, 0, 5)\n    name_square = pygame.draw.rect(SCREEN, colors.BLACK, name_detail, 1, 5)\n    name = self.Hfont.render(character.name, True, colors.BLACK)\n    name_rect = name.get_rect(center=name_square.center)\n    SCREEN.blit(name, name_rect)\n    \n    # draw HP\n    hp = self.font.render(f\"{character.hp}/{character.max_hp}\", True, colors.BLACK)\n    hp_rect = hp.get_rect(center=(portrait.center[0],portrait.center[1] + portrait_rayon - 20))\n    SCREEN.blit(hp, hp_rect)\n    \n    # draw tokens\n    y = y-5 \n    offset_x = 65 + portrait_rayon*2\n    offset_y = 50\n    \n    token_rayon = 18\n    aura_rayon  = 10\n    token_width = token_rayon * 2\n    \n    def draw_token(color, element):\n      token_positions = {\n        \"earth\" :     (offset_x, y + offset_y),\n        \"water\" :     (offset_x + token_width, y + offset_y),\n        \"fire\" :      (offset_x, y + offset_y + token_width),\n        \"neutral\" :   (offset_x + token_width, y + offset_y + token_width),\n      }\n      \n      aura_positions = {\n        \"earth\" :     (offset_x - 18, y + offset_y + 5),\n        \"water\" :     (offset_x + token_width + 18, y + offset_y + 5),\n        \"fire\" :      (offset_x - 18, y + offset_y + token_width + 5),\n        \"neutral\" :   (offset_x + token_width + 18, y + offset_y + token_width + 5),\n      }\n      \n      token = pygame.draw.circle(SCREEN, color, token_positions[element] , token_rayon )\n      token_value = self.font.render(str(character.tokens[element]), True, colors.BLACK)\n      token_value_rect = token_value.get_rect(center=token.center)\n      SCREEN.blit(token_value,token_value_rect)\n\n      aura = pygame.draw.circle(SCREEN, color, aura_positions[element] , aura_rayon )\n      aura_border = pygame.draw.circle(SCREEN, colors.BLACK, aura_positions[element] , aura_rayon, 1 )\n      aura_value = self.font.render(str(character.aura[element]), True, colors.BLACK)\n      aura_value_rect = aura_value.get_rect(center=aura.center)\n      aura_border_rect = aura_value.get_rect(center=aura.center)\n      SCREEN.blit(aura_value,aura_value_rect)\n      \n    draw_token(colors.BLUE  , \"water\"   )\n    draw_token(colors.GREEN , \"earth\"   )\n    draw_token(colors.RED   , \"fire\"    )\n    draw_token(colors.ORANGE, \"neutral\" )\n\n  def draw_buttons(self, SCREEN):\n    if self.game_state.attacking:\n      for button in self.attack_buttons:\n        button.draw(SCREEN)\n    elif self.game_state.moving:\n      print('movin')\n      self.cancel_btn.draw(SCREEN)\n    elif self.character is not False:\n      for button in self.character_buttons:\n        button.draw(SCREEN)\n\n  def draw(self, SCREEN):\n    self.current_turn.draw(SCREEN)\n    self.turn_button.draw(SCREEN)\n    self.turn_banner.draw(SCREEN)\n    \n    if self.character:\n      x, y, = (self.char_anchor[\"x\"], self.char_anchor[\"y\"])\n      self.draw_buttons(SCREEN)\n      self.create_token_ui(self.character, x, y)\n\n    for info in self.infos[:]:\n      info.update()\n      if info.alpha == 0:\n        self.infos.remove(info)\n\n            \n",
  "./classes/character.py": "import pygame\nimport math\n\nclass Character:\n  def __init__(self, name, hp, steps, mp, sprite_sheet, spells, directions, width, height, offsetx = 0, offsety = 0):\n    self.name = name\n    self.spells = spells\n    self.hp = hp\n    self.max_hp = hp\n    self.max_mp = mp\n    self.mp = mp\n    self.sprite = sprite_asset(steps, 4, sprite_sheet, directions, width, height)\n    self.width = width\n    self.height = height\n    self.animation = AnimatedSprite(self)\n    self.steps = steps\n    self.offsetx = offsetx\n    self.offsety = offsety\n    self.status = []\n    self.max_tokens = { \"fire\": 6, \"water\": 6, \"earth\": 6, \"neutral\":6}\n    self.tokens = { \"fire\": 6, \"water\": 6, \"earth\": 6, \"neutral\":6}\n    self.aura   = { \"fire\": 6, \"water\": 6, \"earth\": 6, \"neutral\":6}\n\n  def add_tokens(self, element, qte):\n    self.tokens[element] = self.tokens[element] + qte\n\n  def remove_tokens(self, element, qte):\n    self.tokens[element] = self.tokens[element] + qte\n\n  def turn_reset(self, turn):\n    pa = turn * 0.5\n    if pa < 6: self.tokens['neutral'] = math.ceil(pa)\n    else: self.tokens['neutral'] = 6\n\nclass AnimatedSprite:\n  def __init__(self, sprite):\n    self.parent = sprite\n    self.frames = sprite.sprite\n    self.animation_speed = 200\n    self.current_frame = 0\n    self.last_update = pygame.time.get_ticks()\n    self.idle = True\n\n  def set_idle(self):\n    self.idle = True\n    self.current_frame = 0\n      \n  def update(self):\n    if self.idle == True:\n      return\n    now = pygame.time.get_ticks()\n\n    if now - self.last_update > self.animation_speed:\n      self.last_update = now\n      self.current_frame = (self.current_frame + 1) % self.parent.steps\n\ndef get_sprite(sprite_sheet, row, col, width, height):\n  sprite = pygame.Surface((width, height), pygame.SRCALPHA)\n  sprite.blit(sprite_sheet, (0, 0), (col * width, row * height, width, height))\n  sprite.set_colorkey((255,255,255))\n  return sprite\n\ndef sprite_asset(cols, rows, path, directions, width, height):\n  sprite_sheet = pygame.image.load(path)\n  sheet_width, sheet_height = sprite_sheet.get_size()\n  sprite_width = sheet_width // cols\n  sprite_height = sheet_height // cols\n  \n  sprites = {\"top\": [], \"bottom\": [], 'left': [], \"right\": []}\n  sprites['steps'] = cols \n \n  row = 0\n  for direction in  directions:\n    for col in range(cols):\n      sprite = get_sprite(sprite_sheet, row, col, sprite_width, sprite_height)\n      sprite = pygame.transform.scale(sprite, (width, height))\n      sprites[direction].append(sprite)\n    row = row +1\n      \n  return sprites\n",
  "./classes/grid.py": "import pygame\nfrom utils.constants import SIZE, SCREEN, HEIGHT, WIDTH, GUTTER, ROWS, COLLS, SIZE, CELL_SIZE, MARGIN\nfrom utils.colors import colors\n\nclass Pion:\n  def __init__(self, team, position, character):\n    self.team = team\n    self.position = position\n    self.character = character\n\n  def move(self, destination, grid):\n    self.character.mp = (self.character.mp - \n      (abs(self.position[0] - destination.x) + \n      abs(self.position[1] - destination.y) ))\n    origin = grid.cells[self.position[0]][self.position[1]]\n    grid.move(origin, destination)\n\n  def loose_pv(self, dmg):\n    self.character.hp = self.character.hp - dmg\n    return self.character.hp\n  \n  def detail(self):\n    print('======')\n    print(f\"name: {self.character.name}\")\n    print(f\"hp: {self.character.max_hp}/{self.character.hp}\")\n    print(f\"PM: {self.character.max_mp}/{self.character.mp}\")\n    print(f\"team: {self.team}\")\n    print(f\"tokens: {self.character.tokens}\")\n    print(f\"position: {self.position}\")\n\nclass Cell:\n  def __init__(self, x, y, margin, gutter, size, hover, active, pion, turn):\n    self.turn = turn\n    self.area = False\n    self.prev = False\n    self.x = x\n    self.y = y\n    self.padding = 5\n    self.dimensions = (size, size)\n\n    self.active = active\n    self.hover = hover\n    self.pion = pion\n    self.is_obstacle = False\n\n    self.body = pygame.Rect(\n      (margin['left'] + x * (size + gutter), margin[\"top\"] + y * (size + gutter)),\n      self.dimensions,\n    )\n\n  def coords(self):\n    return ( self.x,self.y )\n\n  def get_color(self):\n    if self.hover   : return colors.OAK\n    elif self.prev == True: return colors.OAK\n    elif self.active: return colors.ACTIVE\n    elif self.area == \"move\"  : return colors.GREEN\n    elif self.area == \"attack\": return colors.RED\n    else: return colors.ORANGE\n\n  def draw(self, SCREEN, pion_color):\n    pygame.draw.rect(SCREEN, self.get_color(), self.body)\n    if self.pion != None:\n      pygame.draw.circle( SCREEN, pion_color, (self.body.centerx, self.body.centery), self.body.width / 2 - self.padding,)\n      if self.pion.team == self.turn.turn:\n        pygame.draw.rect(SCREEN, colors.RED, self.body, 3)\n\nclass Grid:\n  def __init__(self, width, height, margin, gutter, size, state):\n    self.margin = margin\n    self.gutter = gutter\n    self.size = size\n\n    self.X = width\n    self.Y = height\n    self.spanX = width * (size + gutter)\n    self.spanY = height * (size + gutter)\n\n    self.aoe = set()\n    self.prevision_aoe = set()\n    self.aoe_templates = {\n        \"circle\": {},\n        \"line\": {},\n        \"cross\": {},\n        \"cone\": {}\n    }\n    self.precompute_aoe_templates()\n    self.board = pygame.Rect(self.margin['left'], self.margin[\"top\"], self.spanX, self.spanY)\n    # self.board = False\n\n    self.battle = state\n    self.cells = [\n      [Cell(x, y, margin, gutter, size, False, False, None, self.battle) \n      for y in range(height)] \n      for x in range(width)\n    ]\n    self.hover = False\n    self.active = False\n    for pion in self.battle.LIST_PIONS:\n      x, y = pion.position\n      \n      cell = self.get_cell(x, y)\n      if cell: \n        cell.pion = pion\n\n  def get_cell(self, x,y):\n    \"\"\"Returns a cell at the specified grid coordinates, or None if out of bounds.\"\"\"\n    if 0 <= x < self.X and 0 <= y  < self.Y:\n      return self.cells[x][y]\n    return None\n\n  def get_pion(self,x,y):\n    return self.cells[x][y].pion \n    \n  def activate(self, x, y, ui, ):\n    self.battle.attacking = False\n    self.deactivate(ui)\n    target = self.get_cell(x,y)\n    if (target.pion != None and target.pion.team == self.battle.turn):\n      pion = target.pion\n      pion.character.animation.idle = False\n      self.active = target\n      self.active.active = True\n      # self.battle.ui.set_character( pion.character )\n      self.clean_aoe()\n\n  def move(self, origin,destination):\n    pion = origin.pion\n    destination.pion = pion\n    pion.position = destination.coords()\n    origin.pion = None\n    if origin == self.active:\n      self.active = destination\n      origin.active = False\n      destination.active = True\n    self.clean_aoe()\n    # ui.set_character( battle.LIST_PIONS[pion].character )\n    self.battle.moving = False\n\n  def draw_turn_outline(self, cell):\n    pass\n\n  def paint(self, SCREEN):\n    for x in range(self.X):\n      for y in range(self.Y):\n        cell = self.cells[x][y]\n        cell.hover = True if (x, y) == self.hover else False\n        pion_color = (\n          self.battle.TEAMS[cell.pion.team][\"color\"]\n          if cell.pion != None\n          else None\n        )\n        # if cell.pion and cell.pion.team == self.battle.turn:\n          # self.draw_turn_outline(cell)\n        # gcc\n        cell.draw(SCREEN, pion_color)\n\n    for pion in self.battle.LIST_PIONS:\n      if pion.character != False:\n        if pion.character.animation.idle != True:\n          pion.character.animation.update()\n        cell = self.cells[pion.position[0]][pion.position[1]]\n        SCREEN.blit(\n          pion.character.sprite['bottom'][pion.character.animation.current_frame], \n          (cell.body.centerx - (pion.character.width / 2), cell.body.centery - 20 - (pion.character.width / 2))\n        )\n    #\n  def get_hovered_cell(self, mouse_x, mouse_y):\n    return (\n      int((mouse_x - self.margin['left']) / (self.size + self.gutter)),\n      int((mouse_y - self.margin[\"top\"]) / (self.size + self.gutter))\n    )\n\n  def aoe_attack(self):\n    self.battle.attacking = True\n\n  def aoe_move(self):\n    if self.active is not False:\n      self.battle.moving = True\n      character = self.active.pion.character\n      distance = character.mp\n      character.animation.update()\n      self.draw_aoe(self.active, \"move\", distance, \"circle\", True)\n\n  def clean_aoe(self):\n    if self.aoe != False:\n      for cell in self.aoe:\n        cell.area = False\n      self.aoe.clear()\n      self.battle.moving = False\n\n  def clean_prev(self):\n    if self.prevision_aoe != False:\n      for cell in self.prevision_aoe:\n        cell.prev = False\n      self.prevision_aoe.clear()\n   \n  def deactivate(self, ui):\n    self.clean_aoe()\n    self.battle.attacking = False\n    ui.character = False\n    ui.buttons = []\n    \n    if self.active != False:\n      if self.active.pion:\n        self.active.pion.character.animation.set_idle()\n      \n      self.active.active = False\n      self.active = False\n\n  def remove_pion(self, pion):\n    pion.character = False\n    self.get_cell(*pion.position).pion = None\n    self.battle.LIST_PIONS.remove(pion)\n\n  def set_targets(self, hover):\n    x, y = hover\n    hover_cell = self.cells[x][y]\n    targets = []\n    \n    if len(self.prevision_aoe):\n      for cell in self.prevision_aoe:\n        targets.append(cell)\n    else:\n      targets.append(hover_cell)\n      \n    return targets\n\n\n\n  def precompute_aoe_templates(self):\n      \"\"\"Precompute AoE templates for common shapes and ranges.\"\"\"\n      max_radius = max(self.X, self.Y)\n      for radius in range(1, max_radius + 1):\n          self.aoe_templates[\"circle\"][radius] = self.generate_circle_template(radius)\n          self.aoe_templates[\"line\"][radius] = self.generate_line_template(radius)\n          self.aoe_templates[\"cross\"][radius] = self.generate_cross_template(radius)\n          self.aoe_templates[\"cone\"][radius] = self.generate_cone_template(radius)\n\n  def draw_aoe_from_caster(self,spell):\n    self.battle.active_spell = spell.name\n    self.draw_aoe(self.active, \"attack\", spell.range, spell.aoe, blocking=spell.blocking)\n    ###\n    return\n    \n  def draw_aoe(self, origin, area_type, radius, aoe_type, blocking=False):\n    \"\"\"Marks cells in the grid based on AoE type, range, and obstacle interaction.\"\"\"\n    if area_type != 'prev':\n        self.clean_aoe()\n    else:\n        self.clean_prev()\n\n    area = set()\n    visited = set()\n\n    # Use precomputed offsets for non-blocking AoEs\n    if not blocking and radius in self.aoe_templates[aoe_type]:\n        offsets = self.aoe_templates[aoe_type][radius]\n        for dx, dy in offsets:\n            neighbor = self.get_cell(origin.x + dx, origin.y + dy)\n            if neighbor:\n                area.add(neighbor)\n    else:\n        # Use propagation for blocking AoEs\n        queue = [(origin, 0)]\n\n        while queue:\n            current_cell, distance = queue.pop(0)\n\n            if distance >= radius:\n                continue\n\n            # Fetch valid offsets for the AoE type\n            if aoe_type == \"circle\":\n              offsets = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Cardinal directions\n            elif aoe_type == \"line\":\n              offsets = [(-distance, 0), (distance, 0), (0, -distance), (0, distance)]\n            else:\n              offsets = self.aoe_templates.get(aoe_type, {}).get(radius, [])\n\n            for dx, dy in offsets:\n              neighbor = self.get_cell(current_cell.x + dx, current_cell.y + dy)\n              if neighbor and neighbor not in visited:\n                visited.add(neighbor)\n\n                if blocking and (neighbor.pion or neighbor.is_obstacle):\n                  # area.add(neighbor)\n                  continue\n\n                area.add(neighbor)\n                queue.append((neighbor, distance + 1))\n\n    # Mark the grid cells\n    if area_type == 'prev':\n      self.prevision_aoe = area\n      for cell in self.prevision_aoe:\n        cell.prev = True\n    elif area_type in ['attack', 'move']:\n      self.aoe = area\n      for cell in self.aoe:\n        cell.area = area_type\n\n  def generate_circle_template(self, radius):\n    \"\"\"Generate a set of offsets for a circular AoE of a given radius.\"\"\"\n    offsets = set()\n    for x in range(-radius, radius + 1):\n      for y in range(-radius, radius + 1):\n        if abs(x) + abs(y) <= radius:\n          offsets.add((x, y))\n    return offsets\n\n  def generate_line_template(self, radius):\n      \"\"\"Generate a set of offsets for a line AoE of a given radius.\"\"\"\n      offsets = set()\n      for step in range(1, radius + 1):\n          offsets.update({(-step, 0), (step, 0), (0, -step), (0, step)})\n      return offsets\n\n  def generate_cross_template(self, radius):\n      \"\"\"Generate a set of offsets for a cross-shaped AoE of a given radius.\"\"\"\n      offsets = set()\n      for step in range(radius + 1):\n          offsets.update({(-step, 0), (step, 0), (0, -step), (0, step)})\n      return offsets\n\n  def generate_cone_template(self, radius):\n      \"\"\"Generate a set of offsets for a cone-shaped AoE of a given radius.\"\"\"\n      offsets = set()\n      for step in range(1, radius + 1):\n          base_start = -step + 1\n          base_end = step\n          for offset in range(base_start, base_end):\n              offsets.update({(-step, offset), (step, offset), (offset, -step), (offset, step)})\n      return offsets\n\n        \n\n# grid = Grid(COLLS, ROWS, MARGIN, GUTTER, CELL_SIZE)\n\n\n# HEIGHT = grid.margin[\"top\"] + grid.margin[\"bottom\"] + grid.spanY\n# WIDTH = grid.margin['left'] * 2 + grid.spanX\n",
  "./data/effects.py": "from data.mechanics import Mechanics\nStatus = {}\n\nclass Statut:\n  def __init__(self, name, damage, type, cost, max_level  ):\n    self.name = name            # Name of the status\n    self.damage = damage        # Damage dealt (if applicable)\n    self.cost = cost            # Cost to trigger the status (e.g., tokens in aura)\n    self.type = type            # \"withering\" or other types\n    self.max_level = max_level  # Maximum level for withering statuses\n    self.effect = lambda target: None  # Default effect does nothing\n    \n  def cast(self, target):\n    print(\"================================================\")\n    target_status = next((status for status in target.status if status['name'] == self.name), None)\n    \n    if self.attempt_trigger(target):\n      if target_status is not None:\n        match(self.type):\n          case 'withering': target_status[\"level\"] = self.max_level  \n          case _: target_status[\"level\"] += 1\n      else:\n        match(self.type):\n          case 'withering': \n            target.status.append({\"name\":self.name, \"level\": self.max_level  })\n          case _:\n            target.status.append({\"name\":self.name, \"level\": 1})\n\n      print(f\"Statut => {self.name} Lv: {next(status['level'] for status in target.status if status['name'] == self.name)}\")\n      self.effect(target)\n    else:\n      print(f\"Statut => {self.name} did not trigger\")\n\n  def define_effect(self, effect):\n    self.effect = effect\n\n  def life_cycle(self, target):\n    \"\"\"\n    Handles the progression of the status on the target at the beginning of each turn.\n    \"\"\"\n    target_status = next((status for status in target.status if status.get('name') == self.name), None)\n    print(\"================================================\")\n    \n    if not target_status:\n      return\n\n    trigger = self.attempt_trigger(target)\n    \n    match(self.type):\n      case \"growing\":\n        target_status[\"level\"] += 1 if trigger else -1\n      case 'withering':\n        target_status[\"level\"] = self.max_level if triggered else target_status[\"level\"] - 1\n      case 'static': \n        pass\n      case _: \n        target_status[\"level\"] -= 1\n\n    if target_status['level'] == 0:\n      print(f\"Statut => {self.name} removed on {target.name}\")\n      target.status.remove(target_status)\n    else:\n      print(f\"Statut => {self.name} Lv: {target_status['level']}\")\n      self.effect(target)\n      \n      \n  \n  def attempt_trigger(self, target):\n    \"\"\"\n    Checks if the target is eligible for the status to trigger\n    \n    Parameters:\n        target: The character object target by the spell, with ressources like aura, tokens, hp, etc.\n        \n    Returns:\n        True if the status can be triggered, False otherwise.\n    \"\"\"\n    \n    print(f\"{self.name} attempts to trigger on {target.name}\")\n\n    success = True\n    \n    def check_spell_cost(ressource_name, ressource_pool, cost):\n      check = True\n      available_keys = list(ressource_pool.keys())\n      for element, required_value in cost.items():\n        if element not in ressource_pool:\n          print(f\"Invalid ressource_pool '{element}' in {ressource_name}. Availible: {available_keys}\")\n          check = False\n          continue\n\n        if ressource_pool[element] < required_value:\n          print(f\"Not enough {element} in {ressource_name}: {required_value} needed, {ressource_pool[element]} availible\")\n          check = False\n      return check\n\n    def pay_cost(ressource_pool, cost):\n      for element, required_value in cost.items():\n        ressource_pool[element] -= required_value\n    \n    for stat, value in self.cost.items():\n      match(stat):\n        case \"aura\":\n          if not check_spell_cost('aura', target.aura, value):\n            success = False\n        case \"tokens\":\n          if not check_spell_cost('tokens', target.tokens, value):\n            success = False\n        case 'status':\n          if next((status for status in target.status if status.get('name') == value['name']), None) is  None:\n            print(f\"{target.name} must be under the status {value} to cast this spell\")\n            success = False\n        case _:\n          if not hasattr(target, stat):\n            print(f\"Invalid ressource '{stat}'\")\n            success = False       \n          elif getattr(target, stat, 0) < value:\n            print(f\"Not enough {stat} : {value} needed, {getattr(target, stat, 0)} availible\")\n            success = False       \n          \n    if success:\n      for stat, value in self.cost.items():\n        match(stat):\n          case \"aura\":\n            pay_cost(target.aura, value)\n          case \"tokens\":\n            pay_cost(target.tokens, value)\n          case \"status\":\n            if value[ 'levels' ] == \"A\":\n              target.status.remove(next(status for status in target.status if status['name'] == value['name']))\n            else:\n              next(status for status in target.status if status['name'] == value['name'])['level'] -= value\n          case _:\n            setattr(target, stat, getattr(caster, stat, 0) - value)\n        \n      print(f\"{target.name} is now {self.name}\")\n      return True\n    \n    print(f\"{self.name} did not trigger on {target.name}\")\n    return False\n\n\n# ====== [ Burning ] ======\n# Cost: 3aF\n# direct damage equal to lv\nBurning = Statut('Burning', 1, \"static\", {\"aura\":{\"fire\":3}}, 3)\ndef burning_effect(target):\n  target_burning = next((status for status in target.status if status['name'] == \"Burning\"), None)\n  if target_burning is not None:\n    Mechanics['status_damage'](\"Burning\", target_burning['level'], target)\n\nBurning.define_effect(burning_effect)\n    \n  \nStatus['Burning'] = Burning\n\n    \n",
  "./data/spells.py": "from data.mechanics import Mechanics\nSpells = {}\n    \nclass Spell:\n  def __init__(self, name, reach, aoe, damage, prevision=False, prevision_type=\"circle\", blocking = False):\n    self.name = name\n    self.range = reach\n    self.aoe = aoe\n    self.damage = damage\n    self.prevision_aoe = prevision\n    self.prevision_type = prevision_type\n    self.effect = None\n    self.effects = []\n    self.grid_effects = []\n    self.blocking = blocking\n\n  def define_effect(self, effect):\n    self.effect = effect\n\n  def add_target_effect(self, effect):\n    self.effects.append(effect)\n\n  def add_grid_effect(self, effect):\n    self.grid_effects.append(effect)\n\n  def cast(self, caster, targets, grid, *args):\n    if not isinstance(targets, list):\n      targets = [targets]\n\n    print(\"================================================\")\n    print(f\"Spell => {self.name}\")\n    if self.attempt_cast(caster) :\n      for target in targets:\n        if target and target.pion:\n          for effect in self.effects:\n            effect.cast(target)\n      if len(self.grid_effects):\n        for effect in self.grid_effects:\n          effect.cast(caster,targets,grid)\n\n  def __repr__(self):\n    return (f\"Spell(name={self.name}, range={self.range}, aoe={self.aoe}, \"\n      f\"damage={self.damage}, prevision_aoe={self.prevision_aoe}, \"\n      f\"prevision_type={self.prevision_type}, effect={self.effect})\")\n\n  def attempt_cast(self, caster):\n    \"\"\"\n    Checks if the caster can pay the cost of a spell and deducts the cost if possible.\n    \n    Parameters:\n        caster: The character object casting the spell, with resources like aura, tokens, hp, etc.\n        \n    Returns:\n        True if the spell can be cast, False otherwise.\n    \"\"\"\n    \n    print(f\"{caster.name} attempts to cast, {self.name}\")\n\n    success = True\n    \n    def check_spell_cost(ressource_name, ressource_pool, cost):\n      check = True\n      for element, required_value in cost.items():\n\n        if element not in ressource_pool:\n          print(f\"Invalid ressource_pool '{element}' in {ressource_name}. Availible: {list(ressource_pool.keys())}\")\n          check = False\n          continue\n\n        if ressource_pool[element] < required_value:\n          print(f\"Not enough {element} in {ressource_name}: {required_value} needed, {ressource_pool[element]} availible\")\n          check = False\n      return check\n\n    def pay_cost(ressource_pool, cost):\n      for element, required_value in cost.items():\n        ressource_pool[element] -= required_value\n    \n    for stat, value in self.cost.items():\n      if stat == \"aura\":\n        success = check_spell_cost('aura', caster.aura, value)\n      elif stat == \"tokens\":\n        success = check_spell_cost('tokens', caster.tokens, value)\n      elif stat == \"status\":\n        success = any(status.get('name') == value for status in caster.status)\n        if not success: print(f\"{caster.name} must be under the status {value} to cast this spell\")\n      else:\n        if not stat in dir(caster):\n          print(f\"Invalid ressource_pool '{stat}'\")\n          success = False       \n        elif getattr(caster, stat, 0) < value:\n          print(f\"Not enough {stat} : {value} needed, {getattr(caster, stat, 0)} availible\")\n          success = False       \n          \n    if success:\n      for stat, value in self.cost.items():\n        match(stat):\n          case \"aura\":\n            pay_cost(caster.aura, value)\n          case \"tokens\":\n            pay_cost(caster.tokens, value)\n          case \"status\":\n            next(status for status in caster.status if status['name'] == value)['level'] -= 1\n          case _:\n            setattr(caster, stat, getattr(caster, stat, 0) - value)\n        \n      print(f\"{caster.name} successfully cast {self.name}\")\n      return True\n    \n    print(f\"{caster.name} failed to cast {self.name}\")\n    return False\n\n# ====== [ Fireball ] ======\n# Cost: 2N 1F\n# deal 2 damage and apply one fire token to target\nFireball = Spell('Fireball', 8, \"circle\", 2)\nFireball.cost = {\"tokens\": { \"neutral\": 2, \"fire\": 1}} \nFireball.add_target_effect(Mechanics[ \"Direct_damage\" ](Fireball.damage))\nFireball.add_target_effect(Mechanics[ \"Add_token\" ](\"fire\", 1))\n\n\n# ====== [ Spark ] ======\n# Cost: 1N 1F \n# all fire token of the targets explode adding 2 dmg by token\nSpark = Spell('Spark', 3, \"circle\", 1, 2)\nSpark_splinter = Spell('Splinter', 1, None, 2)\nSpark.cost = {\"tokens\": { \"neutral\": 1, \"fire\": 1}} \nSpark.add_target_effect(Mechanics[\"Direct_damage\"](Spark.damage))\nSpark.add_target_effect(Mechanics[\"Consume_token_and_hurt\"]('fire', Spark_splinter.damage))\n\n# ====== [ Splash ] ======\n# push all targets 1m around to 3 m away\n# apply one water token to targets\n# apply status wet to targets\nSplash = Spell('Splash', 3, \"line\", 0, 3, \"line\", blocking=False)\nSplash.cost = {\"tokens\": {\"neutral\": 3}}\nSplash_projection = Mechanics['Projection'](3)\nSplash_projection.add_collision_effect(Mechanics['Direct_damage'](2))\nSplash.add_target_effect(Mechanics['Add_token'](\"water\", 1))\nSplash.add_grid_effect(Splash_projection)\n\n# ====== [ Frosw Wind ] ======\n\n# ====== [ Stream ] ======\nStream = Spell('Stream', 4, \"line\", 3, 3)\nStream.cost = {\"mp\": 2}\nStream.add_target_effect(Mechanics[ \"Direct_damage\" ](Stream.damage))\n\nSpells[\"Fireball\"] = Fireball\nSpells[\"Spark\"] = Spark\n\nSpells['Stream'] = Stream\nSpells['Splash'] = Splash\n",
  "./data/mechanics.py": "Mechanics = {}\n\nclass Effect:\n  def cast(self, *args):\n    raise NotImplementedError(\"Effects must implement 'cast()'\")\n\nclass Direct_damage(Effect):\n  def __init__(self, damage):\n    self.damage = damage\n\n  def cast(self, target):\n    if target and target.pion:\n      target.pion.loose_pv(self.damage)\n      print(f\"{target.pion.character.name} -{self.damage} pv\")\n\nclass Collision(Effect):\n  def __init__(self):\n    self.effects = []\n    self.grid_effects = []\n\n  def add_target_effect(self, effect):\n    self.effects.append(effect)\n\n  def add_grid_effect(self, effect):\n    self.grid_effects.append(effect)\n\n  def cast(self, target):\n    if target:\n      print(f\"{target.pion.character.name} collided!\")\n      for effect in self.effects:\n          effect.cast(target)\n\nclass Add_token(Effect):\n  def __init__(self, element, qte):\n    self.element = element\n    self.qte = qte\n\n  def cast(self, target):\n    target.pion.character.add_tokens(self.element, self.qte)\n    print(f\"{target.pion.character.name} +{self.qte} {self.element}, tokens\")\n\nclass Consume_token_and_hurt(Effect):\n  def __init__(self, element, damage, multiplicator = 1):\n    self.element = element\n    self.damage = damage * multiplicator\n\n  def cast(self, target):\n    if target and target.pion:\n      token = target.pion.character.tokens[self.element]\n      for _ in range(token):\n        target.pion.loose_pv(self.damage)\n        print(f\"{target.pion.character.name} -{self.damage} pv\")\n      target.pion.character.tokens[self.element] = 0\n\nclass Projection(Effect):\n  def __init__(self, distance):\n    self.contact_effect = Collision()\n    self.distance = distance\n\n  def add_collision_effect(self, effect):\n    self.contact_effect.add_target_effect(effect)\n\n  def cast(self, caster, targets, grid):\n    test = False\n    origin = grid.hover\n    \"\"\"\n      Pushes targets on a grid away from an origin point in specific directions (N, S, E, W) by a specified distance.\n      \n      Args:\n        grid: The game grid, providing methods for cell access and movement.\n        targets: List of cells/entities to be evaluated.\n        origin: (x, y) tuple representing the origin of the push effect.\n        distance: Number of cells to push the targets.\n        contact_effect: (Unused) Whether a contact effect is applied during the push.\n      \n      Returns:\n        None\n    \"\"\"\n\n    def calculate_new_position(direction, position):\n      def detect_collision(x,y, dx, dy, step):\n        x_step, y_step = x + step * dx, y + step * dy\n        obstacle_or_bound = grid.get_cell(x_step, y_step)\n\n        x_in_bounds = -1 < x_step < grid.X\n        y_in_bounds = -1 < y_step < grid.Y\n\n        if test: print(f\"coord { (x_step, y_step) }\")\n        if not x_in_bounds or not y_in_bounds:\n          if test: print(f\"out of bound {(x_step, y_step)}\")\n          if test: print(f\"daplacé à {(x_step -dx, y_step - dy)}\")\n          return  [obstacle_or_bound, (x_step - dx, y_step - dy)]\n        \n        has_obstacle = obstacle_or_bound.pion\n        if test: print(f\"obstacle { obstacle_or_bound }\")\n\n        if has_obstacle:\n          if test: print(f\"obstacle {(x_step, y_step)}\")\n          if test: print(f\"daplacé à {(x_step -dx, y_step - dy)}\")\n          return  [obstacle_or_bound, (x_step - dx, y_step - dy)]\n        return False\n\n      x, y = position\n      \n      match direction:\n        case \"n\": dx, dy = 0, -1\n        case \"s\": dx, dy = 0, 1\n        case \"e\": dx, dy = 1, 0\n        case \"w\": dx, dy = -1, 0\n\n      collision_preview = False\n      new_position = (x + dx * self.distance, y + dy * self.distance)\n    \n      for step in range(1, self.distance+1):\n        collision_detected= detect_collision(x, y, dx, dy, step)\n        if test : print(f\"collision_detected {collision_detected}\")\n        if collision_detected:\n          collision_preview = (abs((self.distance - step-1) * 3), collision_detected)\n          new_position = collision_detected[1]\n          return new_position, collision_preview\n        \n      return new_position, False\n    \n    Cardinals= {\"n\":[], \"s\":[], \"e\":[], \"w\":[]}\n    \n    for target in targets:\n      if target.pion and target.pion.position != origin:\n        x_diff = target.pion.position[0] - origin[0]\n        y_diff = target.pion.position[1] - origin[1]\n        \n        if x_diff == 0: #same column\n          if y_diff < 0: Cardinals[\"n\"].append(target)\n          else: Cardinals[\"s\"].append(target)\n\n        if y_diff == 0: #same row\n          if x_diff < 0: Cardinals[\"w\"].append(target)\n          else: Cardinals[\"e\"].append(target)\n\n    Cardinals['n'].sort(key=lambda  x: x.pion.position[1])\n    Cardinals['s'].sort(key=lambda  x: x.pion.position[1], reverse=True)\n    Cardinals['w'].sort(key=lambda  x: x.pion.position[0])\n    Cardinals['e'].sort(key=lambda  x: x.pion.position[0], reverse=True)\n\n    for direction, targets in Cardinals.items():\n      for target in targets:\n        if test: print(\"======\")\n        new_position, collision_preview = calculate_new_position(direction, target.pion.position)\n        if target.pion.position != new_position:\n          if test: print(f\"nouvelle position{new_position}\")\n          grid.move(target, grid.get_cell( *new_position ))\n          if collision_preview:\n            if test: print(self.contact_effect)\n            # collision_preview[1][1] = grid.get_cell(*collision_preview[1][1])\n            print(collision_preview)\n            # self.contact_effect.cast(*collision_preview)\n            self.contact_effect.cast(grid.get_cell(*collision_preview[1][1]))\n\nclass status:\n  def __init__(self, name, cost, type, max, init, effect, cost_check= False, trigger = False):\n    self.name = name\n    self.cost = cost\n    self.type = type\n    self.max_level = max\n    self.level = init\n    self.effect = effect\n    self.trigger = trigger\n    \n    self.pay_cost = cost_check\n\n  def cast(self, target):\n    if self.pay_cost(self.cost, target):\n      target.status.append(self.name)    \n      self.effect(target)\n      return\n\n  def apply_effect(self, target):\n    if self.type == \"wither\" and pay_cost(self.cost):\n      self.level = self.init\n    elif self.type == \"groth\" and self.level < self.max_level and pay_cost(self.trigger):\n      self.level = self.level + 1\n    else:\n      self.level = self.level - 1\n      \n    self.effect(self, target)\n  \ndef frozen_effect(target):\n  target.pm =0\n\nFrozen = status('Frozen', {\"aura\":{\"water\":3}}, 'wither', 2, 2, frozen_effect)\n\nMechanics[ \"Consume_token_and_hurt\" ] = Consume_token_and_hurt\nMechanics[ \"Direct_damage\" ] = Direct_damage\nMechanics[ \"Add_token\"     ] = Add_token\n# Mechanics[ \"status_damage\" ] = status_damage\nMechanics[ \"Collision\" ] = Collision\nMechanics[ \"Projection\" ] = Projection\n",
  "./utils/colors.py": "class Colors:\n  def __init__(self):\n    self.WHITE = (255, 241, 215)\n    self.BLUE  = (93, 100, 190)\n    self.GREEN = (44, 199, 33)\n\n    self.ACTIVE = (220, 164, 183)\n\n    self.ORANGE = (250, 170, 117)\n    self.RED = (255, 41, 38)\n    self.OAK = (245, 121, 85)\n\n    self.PURPLE = (125, 82, 222)\n    self.CARMIN = (120, 227, 253)\n\n    self.DARK_BLUE = (0, 100, 200)\n    self.BLACK = (0, 0, 0)\n\ncolors = Colors()\n",
  "./utils/constants.py": "import pygame\n\nWIDTH = 900\nHEIGHT = 700\nSIZE = (WIDTH, HEIGHT)\nSCREEN = pygame.display.set_mode(SIZE)\n\nROWS = 9\nCOLLS = 13\nGUTTER = 1\nCELL_SIZE = 50\n\nMARGIN = {\"top\": (HEIGHT - (ROWS * (CELL_SIZE + GUTTER)) )// 2 , \"left\":(WIDTH - (COLLS * (CELL_SIZE + GUTTER))) // 2, \"bottom\": 100}\n",
  "./utils/__init__.py": "",
  "./utils/functions.py": "from utils.colors import colors\nimport pygame\n\ndef fade_to_black(screen, duration=500):\n\t\"\"\"Fade the screen to black over a given duration (in milliseconds).\"\"\"\n\tfade_surface = pygame.Surface(screen.get_size())\n\tfade_surface.fill((0, 0, 0))\n\t\n\tfor alpha in range(0, 255, 5):  # Adjust step size for speed\n\t\tfade_surface.set_alpha(alpha)  # Set transparency\n\t\tscreen.blit(fade_surface, (0, 0))  # Draw the fade surface\n\t\tpygame.display.flip()\n\t\tpygame.time.delay(duration // 51)  # Total time divided by number of frames (51 in this case)\n\ndef fade_out_surface(screen, turn, color, fade_speed=3):\n\tcenter_surface = pygame.Surface((500, 200), pygame.SRCALPHA)\n\tcenter_surface.fill(color)\n\tfont = pygame.font.Font(None, 100)\n\tturn = font.render(turn, True, colors.BLACK)\n\tturn_surface = turn.get_rect(center=screen.get_rect().center)\n\n\tcenter_rect = center_surface.get_rect(center=screen.get_rect().center)\n\n\talpha = 255\n\n\tdef fade_step():\n\t\tnonlocal alpha  # Reference the alpha value in the outer scope\n\t\tif alpha > 0:\n\t\t\talpha -= fade_speed  # Decrease alpha to make the surface more transparent\n\t\t\tscreen.blit(turn, turn_surface)\n\t\t\tif alpha < 0:\n\t\t\t\talpha = 0\n\t\t\tcenter_surface.set_alpha(alpha)  # Apply alpha transparency\n\t\t\n\t\tscreen.blit(center_surface, center_rect)\n\t\n\treturn fade_step\n"
}