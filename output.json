{
  "./main.py": "import pygame\nfrom scenes.scene_manager import SceneManager\nfrom state.grid_state import State\n\npygame.init()\n\nSceneManager(State()).run()\n\npygame.quit()\n",
  "./classes\\character.py": "import pygame\nimport math\n\nclass Character:\n  def __init__(self, name, hp, steps, mp, sprite_sheet, spells, directions, width, height, offsetx = 0, offsety = 0):\n    self.name = name\n    self.spells = spells\n    self.hp = hp\n    self.max_hp = hp\n    self.max_mp = mp\n    self.mp = mp\n    self.sprite = sprite_asset(steps, 4, sprite_sheet, directions, width, height)\n    self.width = width\n    self.height = height\n    self.animation = AnimatedSprite(self)\n    self.steps = steps\n    self.offsetx = offsetx\n    self.offsety = offsety\n    self.status = [{\"name\":\"Burning\", \"level\":1}]\n    self.max_tokens = { \"fire\": 6, \"water\": 6, \"earth\": 6, \"neutral\":6}\n    self.tokens = { \"fire\": 6, \"water\": 6, \"earth\": 6, \"neutral\":6}\n    self.aura   = { \"fire\": 6, \"water\": 6, \"earth\": 6, \"neutral\":6}\n\n  def add_tokens(self, element, qte):\n    self.tokens[element] = self.tokens[element] + qte\n\n  def remove_tokens(self, element, qte):\n    self.tokens[element] = self.tokens[element] + qte\n\n  def turn_reset(self, turn):\n    pa = turn * 0.5\n    if pa < 6: self.tokens['neutral'] = math.ceil(pa)\n    else: self.tokens['neutral'] = 6\n\nclass AnimatedSprite:\n  def __init__(self, sprite):\n    self.parent = sprite\n    self.frames = sprite.sprite\n    self.animation_speed = 200\n    self.current_frame = 0\n    self.last_update = pygame.time.get_ticks()\n    self.idle = True\n\n  def set_idle(self):\n    self.idle = True\n    self.current_frame = 0\n      \n  def update(self):\n    if self.idle == True:\n      return\n    now = pygame.time.get_ticks()\n\n    if now - self.last_update > self.animation_speed:\n      self.last_update = now\n      self.current_frame = (self.current_frame + 1) % self.parent.steps\n\ndef get_sprite(sprite_sheet, row, col, width, height):\n  sprite = pygame.Surface((width, height), pygame.SRCALPHA)\n  sprite.blit(sprite_sheet, (0, 0), (col * width, row * height, width, height))\n  sprite.set_colorkey((255,255,255))\n  return sprite\n\ndef sprite_asset(cols, rows, path, directions, width, height):\n  sprite_sheet = pygame.image.load(path)\n  sheet_width, sheet_height = sprite_sheet.get_size()\n  sprite_width = sheet_width // cols\n  sprite_height = sheet_height // cols\n  \n  sprites = {\"top\": [], \"bottom\": [], 'left': [], \"right\": []}\n  sprites['steps'] = cols \n \n  row = 0\n  for direction in  directions:\n    for col in range(cols):\n      sprite = get_sprite(sprite_sheet, row, col, sprite_width, sprite_height)\n      sprite = pygame.transform.scale(sprite, (width, height))\n      sprites[direction].append(sprite)\n    row = row +1\n      \n  return sprites\n",
  "./classes\\grid.py": "import pygame\nfrom utils.constants import SIZE, SCREEN, HEIGHT, WIDTH, GUTTER, ROWS, COLLS, SIZE, CELL_SIZE, MARGIN\nfrom utils.colors import colors\n\n\nclass Pion:\n  def __init__(self, team, position, character):\n    self.team = team\n    self.position = position\n    self.character = character\n\n  def move(self, destination, grid):\n    self.character.mp = (self.character.mp - \n      (abs(self.position[0] - destination.x) + \n      abs(self.position[1] - destination.y) ))\n    origin = grid.cells[self.position[0]][self.position[1]]\n    grid.move(origin, destination)\n\n  def loose_pv(self, dmg):\n    self.character.hp = self.character.hp - dmg\n    return self.character.hp\n  \n  def detail(self):\n    print('======')\n    print(f\"name: {self.character.name}\")\n    print(f\"hp: {self.character.max_hp}/{self.character.hp}\")\n    print(f\"PM: {self.character.max_mp}/{self.character.mp}\")\n    print(f\"team: {self.team}\")\n    print(f\"tokens: {self.character.tokens}\")\n    print(f\"position: {self.position}\")\n\n      \nclass Cell:\n  def __init__(self, x, y, margin, gutter, size, hover, active, pion, turn):\n    self.turn = turn\n    self.area = False\n    self.prev = False\n    self.x = x\n    self.y = y\n    self.padding = 5\n    self.dimensions = (size, size)\n\n    self.active = active\n    self.hover = hover\n    self.pion = pion\n\n    self.body = pygame.Rect(\n      (margin['left'] + x * (size + gutter), margin[\"top\"] + y * (size + gutter)),\n      self.dimensions,\n    )\n    \n  def coords(self):\n    return ( self.x,self.y )\n\n  def get_color(self):\n    if self.hover   : return colors.OAK\n    elif self.prev == True: return colors.OAK\n    elif self.active: return colors.ACTIVE\n    elif self.area == \"move\"  : return colors.GREEN\n    elif self.area == \"attack\": return colors.RED\n    else: return colors.ORANGE\n\n  def draw(self, SCREEN, pion_color):\n    pygame.draw.rect(SCREEN, self.get_color(), self.body)\n    if self.pion != None:\n      pygame.draw.circle( SCREEN, pion_color, (self.body.centerx, self.body.centery), self.body.width / 2 - self.padding,)\n      if self.pion.team == self.turn.turn:\n        pygame.draw.rect(SCREEN, colors.RED, self.body, 3)\n      \nclass Grid:\n  def __init__(self, width, height, margin, gutter, size, state):\n    self.margin = margin\n    self.gutter = gutter\n    self.size = size\n\n    self.X = width\n    self.Y = height\n    self.spanX = width * (size + gutter)\n    self.spanY = height * (size + gutter)\n\n    self.aoe = {}\n    self.prevision_aoe = {}\n    self.board = pygame.Rect(self.margin['left'], self.margin[\"top\"], self.spanX, self.spanY)\n    # self.board = False\n\n    self.battle = state\n    self.cells = [\n      [Cell(x, y, margin, gutter, size, False, False, None, self.battle) \n      for y in range(height)] \n      for x in range(width)\n    ]\n    self.hover = False\n    self.active = False\n    for pion in self.battle.LIST_PIONS:\n      x, y = pion.position\n      \n      cell = self.get_cell(x, y)\n      if cell: \n        cell.pion = pion\n\n  def get_cell(self, x,y):\n    if 0 <= x < self.X and 0 <= y  < self.Y:\n      return self.cells[x][y]\n    return None\n\n  def get_pion(self,x,y):\n    return self.cells[x][y].pion \n    \n  def activate(self, x, y, ui, ):\n    self.battle.attacking = False\n    self.deactivate(ui)\n    target = self.get_cell(x,y)\n    if (target.pion != None and target.pion.team == self.battle.turn):\n      pion = target.pion\n      pion.character.animation.idle = False\n      self.active = target\n      self.active.active = True\n      # self.battle.ui.set_character( pion.character )\n      self.clean_aoe()\n\n  def move(self, origin,destination):\n    pion = origin.pion\n    destination.pion = pion\n    pion.position = destination.coords()\n    origin.pion = None\n    if origin == self.active:\n      self.active = destination\n      origin.active = False\n      destination.active = True\n    self.clean_aoe()\n    # ui.set_character( battle.LIST_PIONS[pion].character )\n    self.battle.moving = False\n\n  def draw_turn_outline(self, cell):\n    pass\n\n  def paint(self, SCREEN):\n    for x in range(self.X):\n      for y in range(self.Y):\n        cell = self.cells[x][y]\n        cell.hover = True if (x, y) == self.hover else False\n        pion_color = (\n          self.battle.TEAMS[cell.pion.team][\"color\"]\n          if cell.pion != None\n          else None\n        )\n        # if cell.pion and cell.pion.team == self.battle.turn:\n          # self.draw_turn_outline(cell)\n        # gcc\n        cell.draw(SCREEN, pion_color)\n\n    for pion in self.battle.LIST_PIONS:\n      if pion.character != False:\n        if pion.character.animation.idle != True:\n          pion.character.animation.update()\n        cell = self.cells[pion.position[0]][pion.position[1]]\n        SCREEN.blit(\n          pion.character.sprite['bottom'][pion.character.animation.current_frame], \n          (cell.body.centerx - (pion.character.width / 2), cell.body.centery - 20 - (pion.character.width / 2))\n        )\n    #\n  def get_hovered_cell(self, mouse_x, mouse_y):\n    return (\n      int((mouse_x - self.margin['left']) / (self.size + self.gutter)),\n      int((mouse_y - self.margin[\"top\"]) / (self.size + self.gutter))\n    )\n\n  def aoe_attack(self):\n    self.battle.attacking = True\n\n  def aoe_move(self):\n    if self.active is not False:\n      self.battle.moving = True\n      character = self.active.pion.character\n      distance = character.mp\n      character.animation.update()\n      self.draw_aoe(self.active, \"move\", distance, \"circle\")\n\n  def clean_aoe(self):\n    if self.aoe != False:\n      for cell in self.aoe:\n        cell.area = False\n      self.aoe = {}\n      self.battle.moving = False\n\n  def clean_prev(self):\n    if self.prevision_aoe != False:\n      for cell in self.prevision_aoe:\n        cell.prev = False\n      self.prevision_aoe = {}\n   \n  def deactivate(self, ui):\n    self.clean_aoe()\n    self.battle.attacking = False\n    ui.character = False\n    ui.buttons = []\n    \n    if self.active != False:\n      if self.active.pion:\n        self.active.pion.character.animation.set_idle()\n      \n      self.active.active = False\n      self.active = False\n\n  def remove_pion(self, pion):\n    pion.character = False\n    self.get_cell(*pion.position).pion = None\n    self.battle.LIST_PIONS.remove(pion)\n\n  def set_targets(self, hover):\n    x, y = hover\n    hover_cell = self.cells[x][y]\n    targets = []\n    \n    if len(self.prevision_aoe):\n      for cell in self.prevision_aoe:\n        targets.append(cell)\n    else:\n      targets.append(hover_cell)\n      \n    return targets\n\n  def draw_aoe_from_caster(self,spell):\n    self.battle.active_spell = spell.name\n    self.draw_aoe(self.active, \"attack\", spell.range, spell.aoe)\n    return\n    \n  def draw_aoe(self, origin, area_type, radius, aoe_type):\n    if area_type != 'prev':\n      self.clean_aoe()\n    else:\n      self.clean_prev()\n\n    cells = self.cells\n    visited = set()\n    area = {origin}\n    if aoe_type == \"circle\":\n      queue = [(origin, 0)]\n      while queue:\n          cell, distance = queue.pop(0)\n          \n          if distance >= radius:\n              continue\n\n          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n              nx, ny = cell.x + dx, cell.y + dy\n              if 0 <= nx < self.X and 0 <= ny < self.Y:\n                  neighbor = cells[nx][ny]\n\n                  if neighbor not in visited:\n                    if area_type == \"move\" and neighbor.pion != None:\n                      pass\n                    else:\n                      visited.add(neighbor)\n                      area.add(neighbor)\n                      queue.append((neighbor, distance + 1))  # Add the neighbor to the queue\n\n    elif aoe_type == \"line\":\n      start = origin.x - radius if origin.x - radius >= 0 else 0\n      end   = origin.x + radius +1 if origin.x + radius+1 <= self.X else self.X\n      for x in range(start, end):\n        if x != origin.x:\n          area.add(cells[x][origin.y])\n        else:\n          start = origin.y - radius if origin.y - radius >= 0 else 0\n          end   = origin.y + radius +1 if origin.y + radius+1 <= self.Y else self.Y\n          for cell in cells[x]:\n            if cell.y in range(start,end):\n                area.add(cell)\n\n      \n    if area_type == 'prev':\n      self.prevision_aoe = area\n      for cell in self.prevision_aoe:\n        cell.prev = True  # Assign the area type to each cell\n    elif area_type in ['attack', \"move\"]:\n      self.aoe = area\n      for cell in self.aoe:\n          cell.area = area_type  # Assign the area type to each cell\n\n\n\n        \n\n# grid = Grid(COLLS, ROWS, MARGIN, GUTTER, CELL_SIZE)\n\n\n# HEIGHT = grid.margin[\"top\"] + grid.margin[\"bottom\"] + grid.spanY\n# WIDTH = grid.margin['left'] * 2 + grid.spanX\n",
  "./classes\\scene.py": "class Scene:\n  def __init__(self):\n    pass\n\n  def handle_events(self, event):\n    pass\n\n  def update(self):\n    pass\n\n  def render(self):\n    pass\n",
  "./classes\\ui.py": "import pygame\npygame.font.init()\nfrom utils.colors import colors\nfrom utils.constants import HEIGHT, WIDTH, SCREEN, MARGIN\n\nclass Fade:\n  def __init__(self, x, y, color, info):\n    self.x = x\n    self.y = y\n    self.font = pygame.font.Font(None, 30)\n    self.popup = self.font.render(info, True, color )\n    self.alpha = 255\n    self.fade_speed = 2\n\n  def update(self):\n    self.popup.set_alpha(self.alpha)\n    if self.alpha > 0:\n      self.alpha -= self.fade_speed\n      self.x -= 5\n      if self.alpha < 0:\n        self.alpha = 0\n    SCREEN.blit(self.popup, (self.x, self.y))\n    pygame.display.flip()\n    \nclass Ui:\n  def __init__(self, WIDTH, HEIGHT, battle):\n    self.font  = pygame.font.Font(\"./assets/regular.ttf\", 15)\n    self.Hfont = pygame.font.Font(\"./assets/rounded.ttf\", 17)\n    self.Bfont = pygame.font.Font(\"./assets/regular.ttf\", 15)\n    self.battle = battle\n    self.set_turn()\n    self.clear_aoe = False\n    self.character = False\n    self.turn_button = Button(\n      WIDTH-15-100, 15, \n      100, 35, \n      \"Turn\", \n      colors.BLUE, \n      colors.DARK_BLUE, \n      colors.BLACK, 25, action=self.battle.next_turn)\n    self.character_buttons = []\n    self.attack_buttons = []\n\n    self.infos = []\n\n    self.char_anchor = {\n      \"y\" : HEIGHT - MARGIN[\"bottom\"] -18,\n      \"x\" : 10\n    }\n    self.anchor = pygame.Rect(self.char_anchor[\"x\"], self.char_anchor['y'], 400, MARGIN['bottom'])\n    self.cancel_btn = Button(230, self.char_anchor['y'] + 15, 100, 35, \"Cancel\", colors.BLUE, colors.DARK_BLUE, colors.BLACK, 25, action=lambda: self.cancel_menu(battle))\n\n  def character_info(self, x, y, color, info):\n    fade = Fade(x, y, color, info)\n    self.infos.append(fade)\n    \n  def set_turn(self):\n    self.current_turn = Banner(15, colors.BLACK) \n    self.current_turn.set_text(self.battle.turn)\n    self.current_turn.set_color(self.battle.active_team[\"color\"])\n\n  def cancel_menu(self, battle):\n    self.clear_aoe = True\n    battle.moving = False\n    battle.attacking = False\n\n  def set_character(self, character, battle, grid, ):\n    self.character_buttons.clear()\n    self.attack_buttons.clear()\n    # elements = []\n    elements = {}\n\n    height = grid.spanY + 105\n    margin = grid.margin['left']\n    \n    self.add_character_info(elements, character, margin, height, )\n    self.create_character_buttons(battle, grid)\n    self.create_spell_buttons(character, battle, grid)\n    self.attack_buttons.append(self.cancel_btn)\n    # self.character = elements\n    self.character = character\n\n  def add_character_info(self, elements, character, margin, height, ):\n    name = self.Hfont.render(character.name, True, colors.BLACK)\n    hp = self.font.render(f\"{character.hp}/{character.max_hp}\", True, colors.BLACK)\n    move_info = self.font.render(f\"Mp: {character.mp}/{character.max_mp}\", True, colors.BLACK)\n  \n  def create_character_buttons(self, battle, grid):\n    pos_y = self.char_anchor['y'] + 15\n    bas_x = 230\n \n    width= 100\n    height= 35\n \n    move    = Button(bas_x, pos_y, width, height, \"Move\", colors.BLUE, colors.DARK_BLUE, colors.BLACK, 25, action=grid.aoe_move)\n    attack  = Button(bas_x + width +10, pos_y, width, height, \"Attack\", colors.BLUE, colors.DARK_BLUE, colors.BLACK, 25, action=grid.aoe_attack)\n  \n    self.character_buttons.append(move)\n    self.character_buttons.append(attack)\n\n  def create_spell_buttons(self, character, battle, grid):\n    pos_y = self.char_anchor['y'] + 15\n    bas_x = 230\n    \n    for i, spell in enumerate(character.spells):\n      x = bas_x + (i + 1) * (100 + 15) \n      y = pos_y\n      width, height = (100, 35)\n      btn = Button(\n        x, y, \n        width, height,\n        spell.name, \n        colors.BLUE, \n        colors.DARK_BLUE, \n        colors.BLACK, 25,\n        action=lambda spell=spell: grid.draw_aoe_from_caster(spell)\n      )\n      self.attack_buttons.append(btn)\n\n  def create_token_ui(self, character, x, y):\n    true_character = False\n    for pion in self.battle.LIST_PIONS:\n      if pion.character.name == character.name:\n        true_character = pion.character\n        break\n\n    if not true_character:\n      self.character = False\n      print(\"ERROR => character not found\")\n      return\n    \n    pygame.draw.rect(SCREEN, colors.BLACK, self.anchor , 1)\n    \n    # draw portrait\n    portrait_rayon = (MARGIN['bottom'] )/2\n    portrait_x = x + 20 + portrait_rayon\n    portrait_y = y + portrait_rayon\n    portrait = pygame.draw.circle(SCREEN,colors.BLACK, (portrait_x , portrait_y) , portrait_rayon ,1)\n\n    move_info = self.font.render(f\"Mp: {character.mp}/{character.max_mp}\", True, colors.BLACK)\n    \n    # draw name\n    name_w = (portrait_rayon * 2) - 8\n    name_h = 20\n    name_x = portrait.center[0] - portrait_rayon + 4\n    name_y = portrait.center[1] + portrait_rayon - name_h/2\n    name_detail = ((name_x, name_y),(name_w, 20))\n    pygame.draw.rect(SCREEN, colors.WHITE, name_detail, 0, 5)\n    name_square = pygame.draw.rect(SCREEN, colors.BLACK, name_detail, 1, 5)\n    name = self.Hfont.render(character.name, True, colors.BLACK)\n    name_rect = name.get_rect(center=name_square.center)\n    SCREEN.blit(name, name_rect)\n    \n    # draw HP\n    hp = self.font.render(f\"{character.hp}/{character.max_hp}\", True, colors.BLACK)\n    hp_rect = hp.get_rect(center=(portrait.center[0],portrait.center[1] + portrait_rayon - 20))\n    SCREEN.blit(hp, hp_rect)\n    \n    # draw tokens\n    y = y-5 \n    offset_x = 65 + portrait_rayon*2\n    offset_y = 50\n    \n    token_rayon = 18\n    aura_rayon  = 10\n    token_width = token_rayon * 2\n    \n    def draw_token(color, element):\n      token_positions = {\n        \"earth\" :     (offset_x, y + offset_y),\n        \"water\" :     (offset_x + token_width, y + offset_y),\n        \"fire\" :      (offset_x, y + offset_y + token_width),\n        \"neutral\" :   (offset_x + token_width, y + offset_y + token_width),\n      }\n      \n      aura_positions = {\n        \"earth\" :     (offset_x - 18, y + offset_y + 5),\n        \"water\" :     (offset_x + token_width + 18, y + offset_y + 5),\n        \"fire\" :      (offset_x - 18, y + offset_y + token_width + 5),\n        \"neutral\" :   (offset_x + token_width + 18, y + offset_y + token_width + 5),\n      }\n      \n      token = pygame.draw.circle(SCREEN, color, token_positions[element] , token_rayon )\n      token_value = self.font.render(str(character.tokens[element]), True, colors.BLACK)\n      token_value_rect = token_value.get_rect(center=token.center)\n      SCREEN.blit(token_value,token_value_rect)\n\n      aura = pygame.draw.circle(SCREEN, color, aura_positions[element] , aura_rayon )\n      aura_border = pygame.draw.circle(SCREEN, colors.BLACK, aura_positions[element] , aura_rayon, 1 )\n      aura_value = self.font.render(str(character.aura[element]), True, colors.BLACK)\n      aura_value_rect = aura_value.get_rect(center=aura.center)\n      aura_border_rect = aura_value.get_rect(center=aura.center)\n      SCREEN.blit(aura_value,aura_value_rect)\n      \n    draw_token(colors.BLUE  , \"water\"   )\n    draw_token(colors.GREEN , \"earth\"   )\n    draw_token(colors.RED   , \"fire\"    )\n    draw_token(colors.ORANGE, \"neutral\" )\n\n  def draw(self, SCREEN):\n    self.current_turn.draw(SCREEN)\n    self.turn_button.draw(SCREEN)\n    if self.character:\n      x, y, = (self.char_anchor[\"x\"], self.char_anchor[\"y\"])\n      # for element in self.character:\n      #   SCREEN.blit(element[0], element[1])\n      self.draw_buttons(SCREEN)\n      self.create_token_ui(self.character, x, y)\n\n    for info in self.infos[:]:\n      info.update()\n      if info.alpha == 0:\n        self.infos.remove(info)\n\n  def draw_buttons(self, SCREEN):\n    if self.battle.attacking:\n        for button in self.attack_buttons:\n            button.draw(SCREEN)\n    elif self.battle.moving:\n        print('movin')\n        self.cancel_btn.draw(SCREEN)\n    elif self.character is not False:\n        for button in self.character_buttons:\n            button.draw(SCREEN)\n\n            \nclass Button:\n  def __init__(self, x, y, width, height, text, color, hover_color, text_color, font_size, action=None):\n    self.rect = pygame.Rect(x, y, width, height)\n    self.color = color\n    self.hover_color = hover_color\n    self.text_color = text_color\n    # self.font = pygame.font.Font(None, font_size)\n    self.font = pygame.font.Font(\"./assets/rounded.ttf\", font_size)\n    self.message = text\n    self.text = self.font.render(text, True, self.text_color)\n    self.text_rect = self.text.get_rect(center=self.rect.center)\n    self.action = action  # Function to be called on click\n    self.is_hovered = False\n\n  def draw(self, SCREEN):\n    if self.is_hovered:\n      pygame.draw.rect(SCREEN, self.hover_color, self.rect)\n    else:\n      pygame.draw.rect(SCREEN, self.color, self.rect)\n\n    SCREEN.blit(self.text, self.text_rect)\n\n  def handle_event(self, event):\n    mouse_pos = pygame.mouse.get_pos()\n\n    self.is_hovered = self.rect.collidepoint(mouse_pos)\n\n    if self.is_hovered and event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:\n      if self.action:\n        self.action()\n        \nclass Banner:\n  def __init__(self, x, color):\n    self.x = x\n    self.color = color\n    self.font = pygame.font.Font(None, 30)  # Font size 30\n    self.message = ''  # Placeholder for the message\n  \n  def set_text(self, text): \n    self.message = text\n\n  def set_color(self, color): \n    self.color = color\n\n  def draw(self, SCREEN):\n    text_surface = self.font.render(self.message, True, self.color)\n    \n    rect = text_surface.get_rect()\n    rect.centerx = SCREEN.get_rect().centerx \n    rect.top = self.x  \n\n    SCREEN.blit(text_surface, rect)\n\n",
  "./data\\effects.py": "from data.mechanics import Mechanics\nStatus = {}\n\nclass Statut:\n  def __init__(self, name, damage, type, cost, max_level  ):\n    self.name = name            # Name of the status\n    self.damage = damage        # Damage dealt (if applicable)\n    self.cost = cost            # Cost to trigger the status (e.g., tokens in aura)\n    self.type = type            # \"withering\" or other types\n    self.max_level = max_level  # Maximum level for withering statuses\n    self.effect = lambda target: None  # Default effect does nothing\n    \n  def cast(self, target):\n    print(\"================================================\")\n    target_status = next((status for status in target.status if status['name'] == self.name), None)\n    \n    if self.attempt_trigger(target):\n      if target_status is not None:\n        match(self.type):\n          case 'withering': target_status[\"level\"] = self.max_level  \n          case _: target_status[\"level\"] += 1\n      else:\n        match(self.type):\n          case 'withering': \n            target.status.append({\"name\":self.name, \"level\": self.max_level  })\n          case _:\n            target.status.append({\"name\":self.name, \"level\": 1})\n\n      print(f\"Statut => {self.name} Lv: {next(status['level'] for status in target.status if status['name'] == self.name)}\")\n      self.effect(target)\n    else:\n      print(f\"Statut => {self.name} did not trigger\")\n\n  def define_effect(self, effect):\n    self.effect = effect\n\n  def life_cycle(self, target):\n    \"\"\"\n    Handles the progression of the status on the target at the beginning of each turn.\n    \"\"\"\n    target_status = next((status for status in target.status if status.get('name') == self.name), None)\n    print(\"================================================\")\n    \n    if not target_status:\n      return\n\n    trigger = self.attempt_trigger(target)\n    \n    match(self.type):\n      case \"growing\":\n        target_status[\"level\"] += 1 if trigger else -1\n      case 'withering':\n        target_status[\"level\"] = self.max_level if triggered else target_status[\"level\"] - 1\n      case 'static': \n        pass\n      case _: \n        target_status[\"level\"] -= 1\n\n    if target_status['level'] == 0:\n      print(f\"Statut => {self.name} removed on {target.name}\")\n      target.status.remove(target_status)\n    else:\n      print(f\"Statut => {self.name} Lv: {target_status['level']}\")\n      self.effect(target)\n      \n      \n  \n  def attempt_trigger(self, target):\n    \"\"\"\n    Checks if the target is eligible for the status to trigger\n    \n    Parameters:\n        target: The character object target by the spell, with ressources like aura, tokens, hp, etc.\n        \n    Returns:\n        True if the status can be triggered, False otherwise.\n    \"\"\"\n    \n    print(f\"{self.name} attempts to trigger on {target.name}\")\n\n    success = True\n    \n    def check_spell_cost(ressource_name, ressource_pool, cost):\n      check = True\n      available_keys = list(ressource_pool.keys())\n      for element, required_value in cost.items():\n        if element not in ressource_pool:\n          print(f\"Invalid ressource_pool '{element}' in {ressource_name}. Availible: {available_keys}\")\n          check = False\n          continue\n\n        if ressource_pool[element] < required_value:\n          print(f\"Not enough {element} in {ressource_name}: {required_value} needed, {ressource_pool[element]} availible\")\n          check = False\n      return check\n\n    def pay_cost(ressource_pool, cost):\n      for element, required_value in cost.items():\n        ressource_pool[element] -= required_value\n    \n    for stat, value in self.cost.items():\n      match(stat):\n        case \"aura\":\n          if not check_spell_cost('aura', target.aura, value):\n            success = False\n        case \"tokens\":\n          if not check_spell_cost('tokens', target.tokens, value):\n            success = False\n        case 'status':\n          if next((status for status in target.status if status.get('name') == value['name']), None) is  None:\n            print(f\"{target.name} must be under the status {value} to cast this spell\")\n            success = False\n        case _:\n          if not hasattr(target, stat):\n            print(f\"Invalid ressource '{stat}'\")\n            success = False       \n          elif getattr(target, stat, 0) < value:\n            print(f\"Not enough {stat} : {value} needed, {getattr(target, stat, 0)} availible\")\n            success = False       \n          \n    if success:\n      for stat, value in self.cost.items():\n        match(stat):\n          case \"aura\":\n            pay_cost(target.aura, value)\n          case \"tokens\":\n            pay_cost(target.tokens, value)\n          case \"status\":\n            if value[ 'levels' ] == \"A\":\n              target.status.remove(next(status for status in target.status if status['name'] == value['name']))\n            else:\n              next(status for status in target.status if status['name'] == value['name'])['level'] -= value\n          case _:\n            setattr(target, stat, getattr(caster, stat, 0) - value)\n        \n      print(f\"{target.name} is now {self.name}\")\n      return True\n    \n    print(f\"{self.name} did not trigger on {target.name}\")\n    return False\n\n\n# ====== [ Burning ] ======\n# Cost: 3aF\n# direct damage equal to lv\nBurning = Statut('Burning', 1, \"static\", {\"aura\":{\"fire\":3}}, 3)\ndef burning_effect(target):\n  target_burning = next((status for status in target.status if status['name'] == \"Burning\"), None)\n  if target_burning is not None:\n    Mechanics['status_damage'](\"Burning\", target_burning['level'], target)\n\nBurning.define_effect(burning_effect)\n    \n  \nStatus['Burning'] = Burning\n\n    \n",
  "./data\\mechanics.py": "Mechanics = {}\n\ndef status_damage(name, damage, target):\n  target.hp -= damage\n  print(f\"{target.name} -{damage} pv\")\n\ndef direct_damage(name, damage, targets):\n  for target in targets:\n    if target is not None and target.pion is not None:\n      target.pion.loose_pv(damage)\n      print(f\"{target.pion.character.name} -{damage} pv\")\n\ndef add_token_to_all_targets(targets, element, qte):\n  for x in targets:\n    if x.pion:\n      x.pion.character.add_tokens(element, qte)\n\ndef collision(damage, targets): \n  direct_damage(\"collision\", damage, targets)\n\ndef projection(grid, targets, origin, distance, contact_effect=collision):\n  test = False\n  \"\"\"\n    Pushes targets on a grid away from an origin point in specific directions (N, S, E, W) by a specified distance.\n    \n    Args:\n      grid: The game grid, providing methods for cell access and movement.\n      targets: List of cells/entities to be evaluated.\n      origin: (x, y) tuple representing the origin of the push effect.\n      distance: Number of cells to push the targets.\n      contact_effect: (Unused) Whether a contact effect is applied during the push.\n    \n    Returns:\n      None\n  \"\"\"\n\n  def calculate_new_position(direction, position):\n    \n    def detect_collision(grid, x,y, dx, dy, step):\n      x_step, y_step = x + step * dx, y + step * dy\n      obstacle_or_bound = grid.get_cell(x_step, y_step)\n\n      x_in_bounds = -1 < x_step < grid.X\n      y_in_bounds = -1 < y_step < grid.Y\n\n      if test: print(f\"coord { (x_step, y_step) }\")\n      if not x_in_bounds or not y_in_bounds:\n        if test: print(f\"out of bound {(x_step, y_step)}\")\n        if test: print(f\"daplacé à {(x_step -dx, y_step - dy)}\")\n        return  [obstacle_or_bound, (x_step - dx, y_step - dy)]\n      \n      has_obstacle = obstacle_or_bound.pion\n      if test: print(f\"obstacle { obstacle_or_bound }\")\n\n      if has_obstacle:\n        if test: print(f\"obstacle {(x_step, y_step)}\")\n        if test: print(f\"daplacé à {(x_step -dx, y_step - dy)}\")\n        return  [obstacle_or_bound, (x_step - dx, y_step - dy)]\n      return False\n\n    x, y = position\n    \n    match direction:\n      case \"n\": dx, dy = 0, -1\n      case \"s\": dx, dy = 0, 1\n      case \"e\": dx, dy = 1, 0\n      case \"w\": dx, dy = -1, 0\n\n    collision_preview = False\n    new_position = (x + dx * distance, y + dy * distance)\n  \n    for step in range(1, distance+1):\n      collision_detected= detect_collision(grid, x, y, dx, dy, step)\n      if test : print(f\"collision_detected {collision_detected}\")\n      if collision_detected:\n        collision_preview = (abs((distance - step-1) * 3), collision_detected)\n        new_position = collision_detected[1]\n        return new_position, collision_preview\n      \n    return new_position, False\n  \n  Cardinals= {\"n\":[], \"s\":[], \"e\":[], \"w\":[]}\n  \n  for target in targets:\n    if target.pion and target.pion.position != origin:\n      x_diff = target.pion.position[0] - origin[0]\n      y_diff = target.pion.position[1] - origin[1]\n      \n      if x_diff == 0: #same column\n        if y_diff < 0: Cardinals[\"n\"].append(target)\n        else: Cardinals[\"s\"].append(target)\n\n      if y_diff == 0: #same row\n        if x_diff < 0: Cardinals[\"w\"].append(target)\n        else: Cardinals[\"e\"].append(target)\n\n  Cardinals['n'].sort(key=lambda  x: x.pion.position[1])\n  Cardinals['s'].sort(key=lambda  x: x.pion.position[1], reverse=True)\n  Cardinals['w'].sort(key=lambda  x: x.pion.position[0])\n  Cardinals['e'].sort(key=lambda  x: x.pion.position[0], reverse=True)\n\n  for direction, targets in Cardinals.items():\n    for target in targets:\n      if test: print(\"======\")\n      new_position, collision_preview = calculate_new_position(direction, target.pion.position)\n      if target.pion.position != new_position:\n        if test: print(f\"nouvelle position{new_position}\")\n        grid.move(target, grid.get_cell( *new_position ))\n        if collision_preview:\n          if test: print(contact_effect)\n          collision_preview[1][1] = grid.get_cell(*collision_preview[1][1])\n          contact_effect(*collision_preview)\n\nclass status:\n  def __init__(self, name, cost, type, max, init, effect, cost_check= False, trigger = False):\n    self.name = name\n    self.cost = cost\n    self.type = type\n    self.max_level = max\n    self.level = init\n    self.effect = effect\n    self.trigger = trigger\n    \n    self.pay_cost = cost_check\n\n  def cast(self, target):\n    if self.pay_cost(self.cost, target):\n      target.status.append(self.name)    \n      self.effect(target)\n      return\n\n  def apply_effect(self, target):\n    if self.type == \"wither\" and pay_cost(self.cost):\n      self.level = self.init\n    elif self.type == \"groth\" and self.level < self.max_level and pay_cost(self.trigger):\n      self.level = self.level + 1\n    else:\n      self.level = self.level - 1\n      \n    self.effect(self, target)\n  \ndef frozen_effect(target):\n  target.pm =0\n\nFrozen = status('Frozen', {\"aura\":{\"water\":3}}, 'wither', 2, 2, frozen_effect)\n# Frozen['pay_cost'] = default_cost\n\n        \nMechanics[ \"direct_damage\" ] = direct_damage\nMechanics[ \"status_damage\" ] = status_damage\nMechanics[ \"add_token_to_all_targets\" ] = add_token_to_all_targets\nMechanics[ \"collision\" ] = collision\nMechanics[ \"projection\" ] = projection\n",
  "./data\\spells.py": "from data.mechanics import Mechanics\nSpells = {}\n    \nclass Spell:\n  def __init__(self, name, reach, aoe, damage, prevision=False, prevision_type=\"circle\"):\n    self.name = name\n    self.range = reach\n    self.aoe = aoe\n    self.damage = damage\n    self.prevision_aoe = prevision\n    self.prevision_type = prevision_type\n    self.effect = None\n\n  def define_effect(self, effect):\n    self.effect = effect\n\n  def cast(self, caster, targets, grid):\n    print(\"================================================\")\n    print(f\"Spell => {self.name}\")\n    if self.attempt_cast(caster) :\n      self.effect(targets, grid)\n    \n  def __repr__(self):\n    return (f\"Spell(name={self.name}, range={self.range}, aoe={self.aoe}, \"\n      f\"damage={self.damage}, prevision_aoe={self.prevision_aoe}, \"\n      f\"prevision_type={self.prevision_type}, effect={self.effect})\")\n\n  def attempt_cast(self, caster):\n    \"\"\"\n    Checks if the caster can pay the cost of a spell and deducts the cost if possible.\n    \n    Parameters:\n        caster: The character object casting the spell, with resources like aura, tokens, hp, etc.\n        \n    Returns:\n        True if the spell can be cast, False otherwise.\n    \"\"\"\n    \n    print(f\"{caster.name} attempts to cast, {self.name}\")\n\n    success = True\n    \n    def check_spell_cost(ressource_name, ressource_pool, cost):\n      check = True\n      for element, required_value in cost.items():\n\n        if element not in ressource_pool:\n          print(f\"Invalid ressource_pool '{element}' in {ressource_name}. Availible: {list(ressource_pool.keys())}\")\n          check = False\n          continue\n\n        if ressource_pool[element] < required_value:\n          print(f\"Not enough {element} in {ressource_name}: {required_value} needed, {ressource_pool[element]} availible\")\n          check = False\n      return check\n\n    def pay_cost(ressource_pool, cost):\n      for element, required_value in cost.items():\n        ressource_pool[element] -= required_value\n    \n    for stat, value in self.cost.items():\n      match(stat):\n        case \"aura\":\n          if not check_spell_cost('aura', caster.aura, value):\n            success = False\n        case \"tokens\":\n          if not check_spell_cost('tokens', caster.tokens, value):\n            success = False\n        case 'status':\n          if next((status for status in caster.status if status.get('name') == value), None) is  None:\n            print(f\"{caster.name} must be under the status {value} to cast this spell\")\n            success = False\n        case _:\n          print(stat)\n          if not stat in dir(caster):\n            print(f\"Invalid ressource_pool '{stat}'\")\n            success = False       \n          elif getattr(caster, stat, 0) < value:\n            print(f\"Not enough {stat} : {value} needed, {getattr(caster, stat, 0)} availible\")\n            success = False       \n          \n    if success:\n      for stat, value in self.cost.items():\n        match(stat):\n          case \"aura\":\n            pay_cost(caster.aura, value)\n          case \"tokens\":\n            pay_cost(caster.tokens, value)\n          case \"status\":\n            next(status for status in caster.status if status['name'] == value)['level'] -= 1\n          case _:\n            setattr(caster, stat, getattr(caster, stat, 0) - value)\n        \n      print(f\"{caster.name} successfully cast {self.name}\")\n      return True\n    \n    print(f\"{caster.name} failed to cast {self.name}\")\n    return False\n\n# ====== [ Fireball ] ======\n# Cost: 1N\n# apply one fire token to the target\nFireball = Spell('Fireball', 8, \"circle\", 2)\ndef fireball_effect(target, grid): \n  Mechanics[ \"direct_damage\" ](\"Fireball\", Fireball.damage, target)\n  Mechanics[ \"add_token_to_all_targets\" ](target, 'fire', 1)\nFireball.define_effect( fireball_effect)\nFireball.cost = {\"tokens\": { \"neutral\": 2, \"fire\": 1}} \n\n# ====== [ Spark ] ======\n# Cost: 1F 1PA\n# all fire token of the target explode adding 2 dmg by token \nSpark = Spell('Spark', 3, \"circle\", 1, 2)\nSpark_splinter = Spell('Splinter', 1, None, 2)\ndef spark_effect(target, grid): \n  Mechanics[ \"direct_damage\" ](\"Spark\", Spark.damage, target)\n  for x in target:\n    if x.pion:\n      fire_token = x.pion.character.tokens['fire']\n      for _ in range(fire_token):\n        Mechanics[ \"direct_damage\" ](\"Spark_splinter\", Spark_splinter.damage, [x])\n      fire_token = 0\n  return \nSpark.define_effect( spark_effect )\nSpark.cost = {\"tokens\": { \"neutral\": 1, \"fire\": 1}} \n\n\n# ====== [ Splash ] ======\n# push all targets 1m around to 3 m away\n# apply one water token to targets\n# apply status wet to targets\nSplash = Spell('Splash', 3, \"line\", 0, 3, \"line\")\ndef splash_effect(target, grid):\n  Mechanics[ \"add_token_to_all_targets\" ](target, 'water', 1)\n  Mechanics[ \"projection\" ](grid, target, grid.hover, 3, Mechanics[ \"collision\" ])\nSplash.define_effect( splash_effect)\nSplash.cost = {\"tokens\": {\"neutral\": 3}}\n\n# ====== [ Frosw Wind ] ======\n\n# ====== [ Stream ] ======\nStream = Spell('Stream', 4, \"line\", 3, 3)\ndef water_stream_effect(target, grid):\n  Mechanics[ \"direct_damage\" ](\"Stream\", Stream.damage, target)\nStream.define_effect( water_stream_effect)\nStream.cost = {\"mp\": 2}\n\nSpells[\"Fireball\"] = Fireball\nSpells[\"Spark\"] = Spark\n\nSpells['Stream'] = Stream\nSpells['Splash'] = Splash\n",
  "./scenes\\menu.py": "import pygame\nfrom classes.scene import Scene\n\nclass MenuScene(Scene):\n  def __init__(self):\n      super().__init__()\n      self.font = pygame.font.Font(None, 50)\n      self.bigfont = pygame.font.Font(None, 200)\n      self.smallfont = pygame.font.Font(None, 30)\n\n  def handle_events(self, events):\n      for event in events:\n          if event.type == pygame.KEYDOWN:\n              if event.key == pygame.K_RETURN:  # Press Enter to start game\n                  return 'game'  # Return the name of the next scene\n\n  def render(self, screen):\n      screen.fill((30, 30, 30))  # Dark background\n      name = self.smallfont.render('Beyond the Veil', True, (255, 255, 255))\n      name_rect = name.get_rect(center=(screen.get_width() // 2, screen.get_height() // 3))\n    \n      title = self.bigfont.render('BATTLER', True, (255, 255, 255))\n      title_rect = title.get_rect(center=(screen.get_width() // 2, screen.get_height() // 2))\n    \n      text = self.font.render('Press Enter to Start', True, (255, 255, 255))\n      text_rect = text.get_rect(center=(screen.get_width() // 2, (screen.get_height() // 3 )*2))\n    \n      screen.blit(text, text_rect)\n      screen.blit(title, title_rect)\n      screen.blit(name, name_rect)\n",
  "./scenes\\scene_battle.py": "import pygame\nfrom classes.scene import Scene\nfrom classes.ui import Ui\nfrom data.spells import Spells\nfrom utils.colors import colors\nfrom utils.constants import HEIGHT, WIDTH, GUTTER, ROWS, COLLS, CELL_SIZE, MARGIN, SCREEN\n\nfrom classes.grid import Grid\nfrom data.spells import Spells\nfrom classes.character import Character\nspells = [Spells[\"Fireball\"], Spells['Stream']]\nspells2 = [Spells[\"Splash\"], Spells['Spark']]\n\nLance = Character('Lance', 12, 4, 5, './sprite_sheet/silver.png', spells2, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nGirl  = Character('Girl' ,  2, 4, 3, './sprite_sheet/girl.png'  , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -3)\nTouko = Character('Touko',  2, 4, 4, './sprite_sheet/past.png'  , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60)\n\n\nScott = Character('Scott', 12, 4, 5, './sprite_sheet/Scott.png' , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nGreen = Character('Green', 12, 4, 5, './sprite_sheet/green.png' , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nAzure = Character('Azure', 12, 4, 3, './sprite_sheet/azure.png' , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nclass BattleScene(Scene):\n  def __init__(self, state):\n    super().__init__()\n    self.grid = None\n    self.battle = state\n    self.clicking = False\n    self.actor = False\n    self.battle.setup([Lance, Touko, Girl], [Scott, Green, Azure])\n    self.grid = Grid(COLLS, ROWS, MARGIN, GUTTER, CELL_SIZE, self.battle)\n    self.ui = Ui(WIDTH, HEIGHT, self.battle)\n\n  # Handles player input and updates game state based on events.\n\n  # Mouse Handling:\n  # * Hover Mechanics:\n      # When the mouse hovers over the grid, detects the hovered cell and pion  \n      # If hovering over an \"attack\" area, calculates and displays AoE using the spell's configuration.\n  # * Click Handling:\n      # Executes attacks if in an \"attack\" area, applying spell effects and damage. \n      # Handles movement logic when clicking on a \"move\" area.\n      # Clears AoE indicators and active cells when clicking elsewhere.\n      \n  # Dead characters are removed from the grid.\n\n  def handle_events(self, events):\n    attack_in_progress = self.battle.attacking\n    pygame.draw.rect(SCREEN, colors.BLACK, ((200,200), (50,50)))\n\n    # handle ui buttons\n    for event in events:\n      if attack_in_progress:\n        for button in self.ui.attack_buttons:\n          button.handle_event(event)\n      elif self.battle.moving:\n        self.ui.cancel_btn.handle_event(event)\n      else:\n        for button in self.ui.character_buttons:\n          button.handle_event(event)\n      self.ui.turn_button.handle_event(event)\n\n    self.battle.kill_the_dead(self.grid)\n    \n\n    if self.grid.active and self.grid.active.pion not in self.battle.LIST_PIONS:\n      self.grid.deactivate(self.ui)\n      self.battle.attacking = False\n      self.ui.character = False\n      \n    # handle the mouse clic\n    mouse_x, mouse_y = mouse_pos = pygame.mouse.get_pos()\n    clic, _, _ = pygame.mouse.get_pressed(num_buttons=3)\n    if not clic:\n      self.clicking = False\n\n    # if the mouse hovers the grid\n    if self.grid.board.collidepoint(mouse_pos):\n      self.grid.hover = self.grid.get_hovered_cell(mouse_x, mouse_y)\n      x, y = self.grid.hover\n      hover_cell = self.grid.cells[x][y]\n      hover_pion = hover_cell.pion if hover_cell.pion != None else None\n\n      # draw the spell aoe if the mouse hovers the spell range\n      if hover_cell.area == 'attack':\n        active_spell = Spells[self.battle.active_spell]\n        if active_spell.prevision_aoe:\n          self.grid.draw_aoe(hover_cell, \"prev\", active_spell.prevision_aoe, active_spell.prevision_type)\n      else:\n        self.grid.clean_prev()\n\n      # handle clic events on the grid\n      if clic and not self.clicking:\n        self.clicking = True\n\n        # attack\n        if hover_cell.area == \"attack\":\n          if active_spell:\n            active_spell.cast( self.grid.active.pion.character, self.grid.set_targets((x,y)), self.grid)\n            self.ui.clear_aoe = True\n\n            # visually show damages\n            # for cell in targets:\n            #   if cell.pion:\n                # self.ui.character_info(cell.y, cell.y, colors.RED, \"-\"+str(active_spell.damage))\n                \n        # select grid active pion\n        # checked after attack so it is possible to cast spells on allies\n        elif hover_pion is not None and hover_pion.team == self.battle.turn:\n          self.grid.activate(x, y, self.ui)\n        \n        elif hover_pion is None:\n        # move\n          if hover_cell.area == \"move\":\n            self.grid.active.pion.move(self.grid.get_cell(x,y), self.grid)\n          else : \n            self.grid.deactivate(self.ui)\n    else:\n      self.grid.hover = (None, None)\n      if clic and not self.clicking:\n        self.clicking = True\n\n  def update(self):\n    # change turn\n    if self.battle.change_turn == True:\n      self.next_turn()\n    # clean aoe \n    if self.ui.clear_aoe:\n      self.grid.clean_aoe()\n      self.ui.clear_aoe = False\n    # set/clean ui\n    if self.grid.active :\n      if self.grid.active.pion:\n        self.ui.set_character( self.grid.active.pion.character, self.battle, self.grid)\n      else:\n        self.grid.deactivate(self.ui)\n\n  def render(self, screen):\n    screen.fill(colors.WHITE)\n    self.grid.paint(screen)\n    self.ui.draw(screen)\n    self.ui.draw_buttons(screen)\n    self.battle.fade_turn_pannel()\n\n  def next_turn(self):\n    self.ui.set_turn()\n    self.ui.character = False\n    self.grid.deactivate(self.ui)\n    self.grid.clean_aoe()\n    self.battle.attacking = False\n    self.battle.change_turn = False\n\n",
  "./scenes\\scene_build_team.py": "import pygame\nfrom classes.scene import Scene\nfrom classes.ui import Button\nfrom data.spells import Spells\nfrom classes.character import Character\nfrom utils.colors import colors\nfrom utils.constants import WIDTH, HEIGHT\n\nspells = [Spells[\"Fireball\"], Spells['Stream']]\nspells2 = [Spells[\"Splash\"], Spells['Spark']]\ncharacters = []\nteam = []\nbuttons = []\nspots = []\n\nTouko = Character('Touko',  2, 4, 4, './sprite_sheet/past.png'  , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60)\nGirl  = Character('Girl' ,  2, 4, 3, './sprite_sheet/girl.png'  , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -3)\nScott = Character('Scott', 12, 4, 5, './sprite_sheet/Scott.png' , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nGreen = Character('Green', 12, 4, 5, './sprite_sheet/green.png' , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nAzure = Character('Azure', 12, 4, 3, './sprite_sheet/azure.png' , spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nLance = Character('Lance', 12, 4, 5, './sprite_sheet/silver.png', spells2, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60, -6)\nDemo  = Character('Demo' , 12, 4, 3, './sprite_sheet/Demo_sprite2.png', spells, [\"bottom\", \"left\", \"right\", \"top\"], 34, 40, 5)\nProfessor = Character('Professor', 12, 4, 5, './sprite_sheet/professor.png', spells, [\"bottom\", \"left\", \"right\", \"top\"], 60, 60)\n\ncharacters = [Lance,  Azure, Girl, Demo,  Green,  Scott]\n\nclass TeamSelect(Scene):\n  def __init__(self, state):\n    super().__init__()\n    self.font = pygame.font.Font(None, 40)\n    self.next = False\n    self.btn_next = Button(\n      WIDTH - 150, HEIGHT - 150, 130, 50, \"Battle !!!\", colors.BLUE, colors.DARK_BLUE, colors.BLACK, 36,\n      action=self.battle\n    )\n    self.state = state\n\n    for i, character in enumerate(characters):\n      x = (i+1) * 100\n      btn = Button(\n        x, 100, 50, 50, \"\", colors.BLUE, colors.DARK_BLUE, colors.BLACK, 36,\n        action=lambda ch=character: self.add_to_team(ch)\n      )\n      buttons.append(btn)\n\n  def handle_events(self, events):\n    if self.next:\n      return 'battle'\n    for event in events:\n      if event.type == pygame.KEYDOWN:\n        if event.key == pygame.K_ESCAPE:\n          return 'menu'\n\n      for button in buttons:\n        button.handle_event(event)\n\n      for button in spots:\n        button.handle_event(event)\n\n      self.btn_next.handle_event(event)\n        \n  def update(self):\n    pass\n    \n  def render(self, screen):\n    \n    screen.fill((30, 30, 30))  # Dark background\n    title = self.font.render('Chose three members for your team', True, (255, 255, 255))\n    title_rect = title.get_rect(center=(screen.get_width() // 2, 50))\n    screen.blit(title, title_rect)\n\n\n    for i, (character, button) in enumerate(zip(team, spots)):\n      button.draw(screen)\n    \n      sprite = character.sprite[\"bottom\"][0]\n      sprite_rect = sprite.get_rect()\n      sprite_center_x = button.rect.x + (button.rect.width - sprite_rect.width) // 2\n      sprite_center_y = button.rect.y + (button.rect.height - sprite_rect.height) // 2 + character.offsetx\n\n      screen.blit(sprite, (sprite_center_x, sprite_center_y))\n      \n    for i, (character, button) in enumerate(zip(characters, buttons)):\n      button.draw(screen)\n\n      sprite = character.sprite[\"bottom\"][0]\n      sprite_rect = sprite.get_rect()\n      sprite_center_x = button.rect.x + (button.rect.width - sprite_rect.width) // 2\n      sprite_center_y = button.rect.y + (button.rect.height - sprite_rect.height) // 2 + character.offsetx\n\n      screen.blit(sprite, (sprite_center_x, sprite_center_y))\n\n    if len(team) == 3:\n      self.btn_next.draw(screen)\n      \n  def add_to_team(self, character):\n    global spots\n    if len(team) < 3 and character not in team:\n      team.append(character)\n    self.set_spots()\n      \n\n  def set_spots(self,):\n    global spots\n    spots = []\n    for i, member in enumerate(team):\n      x = 250 + (i*100)\n      btn = Button(\n        x, 300, 50, 50, \"\", colors.BLUE, colors.DARK_BLUE, colors.BLACK, 36,\n        action=lambda ch=member: self.rem_from_team(ch)\n      )\n      spots.append(btn)\n\n  def rem_from_team(self, character):\n    if character in team:\n      team.remove(character)\n    self.set_spots()\n      \n  def battle(self):\n    self.next = True\n    self.state.setup(team)\n    \n",
  "./scenes\\scene_manager.py": "import pygame\n\nfrom scenes.menu import MenuScene\nfrom scenes.scene_battle import BattleScene\nfrom scenes.scene_build_team import TeamSelect\n\nfrom classes.ui import Ui\nfrom classes.grid import Grid\n\nfrom utils.functions import fade_to_black\nfrom utils.constants import HEIGHT, WIDTH, GUTTER, ROWS, COLLS, CELL_SIZE, MARGIN, SCREEN\n\nclass SceneManager:\n  def __init__(self, battle_state):\n    self.battle_state = battle_state\n    self.scenes = {\n        'menu': MenuScene(),\n        'game': TeamSelect(self.battle_state),\n        'battle': BattleScene(self.battle_state),\n    }\n    self.current_scene = self.scenes['battle']\n\n  def switch_scene(self, new_scene_name):\n    fade_to_black(SCREEN)\n    self.current_scene = self.scenes[new_scene_name]\n\n    if new_scene_name == 'battle':\n      self.scenes[\"battle\"].grid = Grid(COLLS, ROWS, MARGIN, GUTTER, CELL_SIZE, self.battle_state)\n      self.scenes['battle'].ui = Ui(WIDTH, HEIGHT, self.battle_state)\n\n  def run(self):\n    clock = pygame.time.Clock()\n    running = True\n    while running:\n      events = pygame.event.get()\n      for event in events:\n        if event.type == pygame.QUIT:\n          running = False\n      \n      next_scene = self.current_scene.handle_events(events)\n      if next_scene:\n        self.switch_scene(next_scene)\n\n      self.current_scene.update()\n      self.current_scene.render(SCREEN)\n  \n      pygame.display.flip()\n      clock.tick(60)\n",
  "./scenes\\__init__.py": "",
  "./state\\grid_state.py": "import pygame\nfrom data.spells import Spells\nfrom data.effects import Status\n\nfrom utils.colors import colors\nfrom utils.constants import SCREEN\nfrom utils.functions import fade_out_surface\n\nfrom classes.grid import Pion\nfrom classes.character import Character\n\npygame.font.init()\n\nclass State():\n  def __init__(self):\n    self.turn = 'Team 1'\n    self.turn_number = 1\n    self.LIST_PIONS = []\n    self.TEAMS = {\n      \"Team 1\": {\"color\": colors.PURPLE, \"pions\": []},\n      \"Team 2\": {\"color\": colors.CARMIN, \"pions\": []},\n    }\n    self.active_team = self.TEAMS[self.turn]\n    self.moving = False\n    self.attacking = False\n    self.active_spell = False\n    self.change_turn = False\n    self.fade_turn_pannel = fade_out_surface(SCREEN, 'Team 1', self.TEAMS[self.turn][\"color\"])\n\n  def kill_the_dead(self, grid):\n    # for pion in self.LIST_PIONS[:]:\n    #   if pion.character.hp <= 0:\n    #     grid.remove_pion(pion)\n      \n    for pion in self.LIST_PIONS[:]:  # Iterate over a copy of the list\n      if pion.character.hp <= 0:\n        grid.remove_pion(pion)\n          # pion.character = False\n          # grid.get_cell(*pion.position).pion = None\n          # self.LIST_PIONS.remove(pion)  # Modify the original list\n          #   \n  def next_turn(self):\n    self.turn = \"Team 2\" if self.turn == \"Team 1\" else \"Team 1\"\n    if self.turn == \"Team 1\": self.turn_number += 1\n    self.fade_turn_pannel = fade_out_surface(SCREEN, self.turn, self.TEAMS[self.turn][\"color\"])\n    for pion in self.TEAMS[self.turn][ \"pions\" ]:\n      if pion.character:\n        character = pion.character\n        if character.hp > 0:\n          character.mp = character.max_mp\n          character.turn_reset(self.turn_number)\n        for status in character.status:\n          Status[status['name']].life_cycle(character)\n    self.change_turn = True\n    self.active_team = self.TEAMS[self.turn]\n\n  def setup(self, team, team2):\n    for i, member in enumerate(team):\n      match i:\n        case 0: coord = (2, 2)\n        case 1: coord = (2, 4)\n        case 2: coord = (2, 6)\n      pion = Pion(\"Team 1\", coord, member)\n      self.LIST_PIONS.append(pion)\n      self.TEAMS[\"Team 1\"][\"pions\"].append(pion)\n    \n    for i, char in enumerate(team2):\n      match i:\n        case 0: coord = (10, 2)\n        case 1: coord = (10, 4)\n        case 2: coord = (10, 6)\n      pion = Pion(\"Team 2\", coord, char)\n      self.LIST_PIONS.append(pion)\n      self.TEAMS['Team 2'][\"pions\"].append(pion) \n",
  "./utils\\colors.py": "class Colors:\n  def __init__(self):\n    self.WHITE = (255, 241, 215)\n    self.BLUE  = (93, 100, 190)\n    self.GREEN = (44, 199, 33)\n\n    self.ACTIVE = (220, 164, 183)\n\n    self.ORANGE = (250, 170, 117)\n    self.RED = (255, 41, 38)\n    self.OAK = (245, 121, 85)\n\n    self.PURPLE = (125, 82, 222)\n    self.CARMIN = (120, 227, 253)\n\n    self.DARK_BLUE = (0, 100, 200)\n    self.BLACK = (0, 0, 0)\n\ncolors = Colors()\n",
  "./utils\\constants.py": "import pygame\n\nWIDTH = 900\nHEIGHT = 700\nSIZE = (WIDTH, HEIGHT)\nSCREEN = pygame.display.set_mode(SIZE)\n\nROWS = 9\nCOLLS = 13\nGUTTER = 1\nCELL_SIZE = 50\n\nMARGIN = {\"top\": (HEIGHT - (ROWS * (CELL_SIZE + GUTTER)) )// 2 , \"left\":(WIDTH - (COLLS * (CELL_SIZE + GUTTER))) // 2, \"bottom\": 100}\n",
  "./utils\\functions.py": "from utils.colors import colors\nimport pygame\n\ndef fade_to_black(screen, duration=500):\n\t\"\"\"Fade the screen to black over a given duration (in milliseconds).\"\"\"\n\tfade_surface = pygame.Surface(screen.get_size())\n\tfade_surface.fill((0, 0, 0))\n\t\n\tfor alpha in range(0, 255, 5):  # Adjust step size for speed\n\t\tfade_surface.set_alpha(alpha)  # Set transparency\n\t\tscreen.blit(fade_surface, (0, 0))  # Draw the fade surface\n\t\tpygame.display.flip()\n\t\tpygame.time.delay(duration // 51)  # Total time divided by number of frames (51 in this case)\n\ndef fade_out_surface(screen, turn, color, fade_speed=3):\n\tcenter_surface = pygame.Surface((500, 200), pygame.SRCALPHA)\n\tcenter_surface.fill(color)\n\tfont = pygame.font.Font(None, 100)\n\tturn = font.render(turn, True, colors.BLACK)\n\tturn_surface = turn.get_rect(center=screen.get_rect().center)\n\n\tcenter_rect = center_surface.get_rect(center=screen.get_rect().center)\n\n\talpha = 255\n\n\tdef fade_step():\n\t\tnonlocal alpha  # Reference the alpha value in the outer scope\n\t\tif alpha > 0:\n\t\t\talpha -= fade_speed  # Decrease alpha to make the surface more transparent\n\t\t\tscreen.blit(turn, turn_surface)\n\t\t\tif alpha < 0:\n\t\t\t\talpha = 0\n\t\t\tcenter_surface.set_alpha(alpha)  # Apply alpha transparency\n\t\t\n\t\tscreen.blit(center_surface, center_rect)\n\t\n\treturn fade_step\n",
  "./utils\\__init__.py": ""
}